<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>机器学习数据特征处理教学</title>
    <script src="https://cdn.bootcdn.net/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background: linear-gradient(135deg, #4b6cb7 0%, #182848 100%);
            color: white;
            padding: 2rem 0;
            text-align: center;
            border-radius: 10px;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
        }
        
        .section {
            background: white;
            border-radius: 10px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            transition: transform 0.3s ease;
        }
        
        .section:hover {
            transform: translateY(-5px);
        }
        
        h2 {
            color: #2c3e50;
            margin-bottom: 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #eee;
        }
        
        h3 {
            color: #3498db;
            margin: 1.5rem 0 1rem;
        }
        
        p {
            margin-bottom: 1rem;
        }
        
        ul, ol {
            margin-left: 1.5rem;
            margin-bottom: 1.5rem;
        }
        
        li {
            margin-bottom: 0.5rem;
        }
        
        .code-block {
            background: #2d3748;
            color: #e2e8f0;
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1.5rem 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
        }
        
        .table-container {
            overflow-x: auto;
            margin: 1.5rem 0;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5rem 0;
        }
        
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        
        th {
            background-color: #3498db;
            color: white;
        }
        
        tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        
        .example-box {
            background: #e8f4fc;
            border-left: 4px solid #3498db;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 0 8px 8px 0;
        }
        
        .chart-container {
            height: 300px;
            margin: 2rem 0;
        }
        
        .comparison {
            display: flex;
            flex-wrap: wrap;
            gap: 2rem;
            margin: 2rem 0;
        }
        
        .comparison-item {
            flex: 1;
            min-width: 300px;
            padding: 1.5rem;
            border-radius: 8px;
            background: #f8f9fa;
        }
        
        .warning {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 1rem;
            margin: 1.5rem 0;
            border-radius: 0 8px 8px 0;
        }
        
        .tip {
            background: #d1ecf1;
            border-left: 4px solid #17a2b8;
            padding: 1rem;
            margin: 1.5rem 0;
            border-radius: 0 8px 8px 0;
        }
        
        .interactive-demo {
            background: #f8f9fa;
            padding: 2rem;
            border-radius: 8px;
            margin: 2rem 0;
        }
        
        .demo-controls {
            display: flex;
            gap: 1rem;
            margin: 1.5rem 0;
            flex-wrap: wrap;
        }
        
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #2980b9;
        }
        
        footer {
            text-align: center;
            margin-top: 3rem;
            padding: 1.5rem;
            color: #7f8c8d;
            border-top: 1px solid #eee;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .section {
                padding: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>机器学习数据特征处理教学</h1>
            <p class="subtitle">让数据为机器学习算法做好准备</p>
        </header>
        
        <section class="section">
            <h2>一、什么是特征处理？</h2>
            <p>特征处理就像给数据"化妆"和"整理"，让机器学习算法能更好地理解和学习数据中的规律。就像我们要把食材清洗、切块后才能烹饪一样，原始数据也需要经过处理才能被算法有效使用。</p>
            
            <div class="example-box">
                <h3>直观比喻</h3>
                <p>想象一下你要教一个外星人识别水果：</p>
                <ul>
                    <li><strong>原始数据</strong>：一堆形状、颜色、大小各异的水果</li>
                    <li><strong>特征处理</strong>：测量每个水果的尺寸、记录颜色、称重量</li>
                    <li><strong>机器学习算法</strong>：外星人学习根据这些特征识别水果</li>
                </ul>
                <p>没有特征处理，外星人面对的就是一堆混乱的水果；经过特征处理，外星人获得了有组织的、可理解的信息。</p>
            </div>
        </section>
        
        <section class="section">
            <h2>二、常见的特征处理方法</h2>
            
            <h3>1. 数值型数据的处理</h3>
            
            <h4>缺失值处理：</h4>
            <ul>
                <li><strong>删除法</strong>：直接删除有缺失值的样本（数据量充足时）</li>
                <li><strong>填充法</strong>：
                    <ul>
                        <li>用均值、中位数填充（适合数据分布均匀时）</li>
                        <li>用0填充（适合稀疏数据）</li>
                        <li>用模型预测填充（更精确但复杂）</li>
                    </ul>
                </li>
            </ul>
            
            <div class="interactive-demo">
                <h4>标准化与归一化可视化</h4>
                <p>调整下面的参数，观察数据分布如何变化：</p>
                
                <div class="demo-controls">
                    <div>
                        <label for="dataRange">数据范围:</label>
                        <input type="range" id="dataRange" min="1" max="100" value="50">
                    </div>
                    <button id="standardizeBtn">标准化</button>
                    <button id="normalizeBtn">归一化</button>
                    <button id="resetBtn">重置数据</button>
                </div>
                
                <div class="chart-container">
                    <canvas id="scalingChart"></canvas>
                </div>
            </div>
            
            <h4>标准化（Standardization）：</h4>
            <div class="code-block">
# 将数据转换为均值为0，标准差为1的分布
标准化后数据 = (原始数据 - 均值) / 标准差
            </div>
            <p><strong>适用场景</strong>：数据分布近似正态分布，且算法对特征尺度敏感（如SVM、逻辑回归）</p>
            
            <h4>归一化（Normalization）：</h4>
            <div class="code-block">
# 将数据缩放到[0,1]区间
归一化后数据 = (原始数据 - 最小值) / (最大值 - 最小值)
            </div>
            <p><strong>适用场景</strong>：需要限定数据范围，如图像处理、神经网络</p>
            
            <h3>2. 类别型数据的处理</h3>
            
            <h4>独热编码（One-Hot Encoding）：</h4>
            <ul>
                <li>将每个类别转换为一个二进制列</li>
                <li>例如：颜色["红","蓝","绿"] → [[1,0,0], [0,1,0], [0,0,1]]</li>
            </ul>
            <p><strong>适用场景</strong>：类别间无顺序关系，且类别数量较少</p>
            
            <h4>标签编码（Label Encoding）：</h4>
            <ul>
                <li>将类别转换为数字标签</li>
                <li>例如：["高","中","低"] → [2,1,0]</li>
            </ul>
            <p><strong>适用场景</strong>：类别间有明确的顺序关系</p>
            
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th>原始数据</th>
                            <th>独热编码</th>
                            <th>标签编码</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>红</td>
                            <td>[1, 0, 0]</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>蓝</td>
                            <td>[0, 1, 0]</td>
                            <td>1</td>
                        </tr>
                        <tr>
                            <td>绿</td>
                            <td>[0, 0, 1]</td>
                            <td>2</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <h3>3. 文本数据的处理</h3>
            
            <h4>词袋模型（Bag of Words）：</h4>
            <ul>
                <li>统计每个词在文本中出现的次数</li>
            </ul>
            <p><strong>适用场景</strong>：简单的文本分类</p>
            
            <h4>TF-IDF：</h4>
            <ul>
                <li>不仅考虑词频，还考虑词的稀有程度</li>
            </ul>
            <p><strong>适用场景</strong>：更精确的文本分析</p>
        </section>
        
        <section class="section">
            <h2>三、如何选择特征处理方法？</h2>
            
            <h3>根据数据类型选择：</h3>
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th>数据类型</th>
                            <th>推荐处理方法</th>
                            <th>说明</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>连续数值</td>
                            <td>标准化/归一化</td>
                            <td>消除量纲影响</td>
                        </tr>
                        <tr>
                            <td>离散数值</td>
                            <td>考虑是否作为类别处理</td>
                            <td>根据业务意义决定</td>
                        </tr>
                        <tr>
                            <td>有序类别</td>
                            <td>标签编码</td>
                            <td>保留顺序信息</td>
                        </tr>
                        <tr>
                            <td>无序类别</td>
                            <td>独热编码</td>
                            <td>避免引入虚假顺序</td>
                        </tr>
                        <tr>
                            <td>文本数据</td>
                            <td>TF-IDF/词袋模型</td>
                            <td>转换为数值特征</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <h3>根据算法选择：</h3>
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th>算法类型</th>
                            <th>特征处理需求</th>
                            <th>说明</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>树模型（决策树、随机森林）</td>
                            <td>对特征尺度不敏感</td>
                            <td>通常不需要标准化</td>
                        </tr>
                        <tr>
                            <td>距离模型（KNN、SVM）</td>
                            <td>对特征尺度敏感</td>
                            <td>必须标准化</td>
                        </tr>
                        <tr>
                            <td>线性模型（线性回归、逻辑回归）</td>
                            <td>建议标准化</td>
                            <td>加快收敛</td>
                        </tr>
                        <tr>
                            <td>神经网络</td>
                            <td>必须标准化/归一化</td>
                            <td>提高训练效率和稳定性</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>
        
        <section class="section">
            <h2>四、保持训练集和测试集特征处理的一致性</h2>
            
            <h3>为什么重要？</h3>
            <p>想象一下：你用训练集的"尺子"来测量训练数据，但用测试集的"尺子"来测量测试数据，这样得到的结果是没有可比性的！</p>
            
            <div class="comparison">
                <div class="comparison-item">
                    <h4>错误做法：</h4>
                    <div class="code-block">
# 错误：分别处理训练集和测试集<br/>
train_scaled = (train_data - train_data.mean()) / train_data.std()<br/>
test_scaled = (test_data - test_data.mean()) / test_data.std()<br/>
                    </div>
                    <div class="warning">
                        <p><strong>问题：</strong>训练集和测试集使用了不同的均值和标准差，导致尺度不一致！</p>
                    </div>
                </div>
                
                <div class="comparison-item">
                    <h4>正确做法：</h4>
                    <div class="code-block">
# 正确：用训练集的参数处理测试集<br/>
train_mean = train_data.mean()<br/>
train_std = train_data.std()<br/>

train_scaled = (train_data - train_mean) / train_std<br/>
test_scaled = (test_data - train_mean) / train_std<br/>
                    </div>
                    <div class="tip">
                        <p><strong>优势：</strong>保持了一致的尺度，确保模型评估的准确性！</p>
                    </div>
                </div>
            </div>
            
            <h3>实用技巧：</h3>
            
            <h4>1. 使用scikit-learn的Pipeline：</h4>
            <div class="code-block">
from sklearn.pipeline import Pipeline<br/>
from sklearn.preprocessing import StandardScaler<br/>

pipeline = Pipeline([
    ('scaler', StandardScaler()),  # 特征处理<br/>
   &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ('model', YourModel())         # 机器学习模型
])

# 自动保持一致性<br/>
pipeline.fit(X_train, y_train)<br/>
pipeline.predict(X_test)<br/>
            </div>
            
            <h4>2. 保存处理参数：</h4>
            <div class="code-block">
# 训练时<br/>
scaler = StandardScaler()<br/>
X_train_scaled = scaler.fit_transform(X_train)<br/>

# 保存scaler的参数<br/>
mean = scaler.mean_<br/>
std = scaler.scale_<br/>

# 测试时使用相同的参数<br/>
X_test_scaled = (X_test - mean) / std<br/>
            </div>
        </section>
        
        <section class="section">
            <h2>五、实际工作流程示例</h2>
            
            <div class="code-block">
# 1. 数据准备<br/>
X_train, X_test, y_train, y_test = train_test_split(data, target)<br/>

# 2. 定义处理策略<br/>
numeric_features = ['age', 'income']  # 数值特征<br/>
categorical_features = ['gender', 'education']  # 类别特征<br/>

# 3. 创建处理管道<br/>
preprocessor = ColumnTransformer(
    transformers=[
        ('num', StandardScaler(), numeric_features),<br/>
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  ('cat', OneHotEncoder(), categorical_features)
    ])
<br/>
# 4. 创建完整管道（处理+模型）<br/>
model = Pipeline([
    ('preprocessor', preprocessor),<br/>
   &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;   ('classifier', LogisticRegression())
])<br/>

# 5. 训练和预测（自动保持一致性）<br/>
model.fit(X_train, y_train)<br/>
predictions = model.predict(X_test)<br/>
            </div>
            
            <div class="tip">
                <p><strong>提示：</strong>使用Pipeline可以确保在交叉验证和模型部署时，特征处理步骤始终保持一致！</p>
            </div>
        </section>
        
        <section class="section">
            <h2>六、总结要点</h2>
            
            <ol>
                <li><strong>先分析</strong>：了解每个特征的类型和分布</li>
                <li><strong>对症下药</strong>：根据特征类型选择合适的处理方法</li>
                <li><strong>保持一致</strong>：永远用训练集的参数处理测试集</li>
                <li><strong>借助工具</strong>：使用Pipeline等工具简化流程</li>
                <li><strong>持续验证</strong>：检查处理后的数据是否符合预期</li>
            </ol>
            
            <div class="example-box">
                <p>记住：特征处理是机器学习成功的关键步骤，好的特征处理能让普通算法表现出色，而糟糕的特征处理会让优秀算法表现平平！</p>
            </div>
        </section>
        
        <footer>
            <p>机器学习数据特征处理教学文档 &copy; 2025 | 河北建材职业技术学院 信息工程系 肖宇鹏</p>
            <p><em>小贴士：在实际项目中，建议将特征处理的参数保存下来，以便在新数据到来时使用相同的处理方式。</em></p>
        </footer>
    </div>

    <script>
        // 初始化图表
        const ctx = document.getElementById('scalingChart').getContext('2d');
        let scalingChart;
        
        // 生成随机数据
        function generateData(range) {
            const data = [];
            for (let i = 0; i < 50; i++) {
                data.push(Math.random() * range);
            }
            return data;
        }
        
        // 标准化函数
        function standardize(data) {
            const mean = data.reduce((a, b) => a + b) / data.length;
            const std = Math.sqrt(data.reduce((sq, n) => sq + Math.pow(n - mean, 2), 0) / data.length);
            return data.map(x => (x - mean) / std);
        }
        
        // 归一化函数
        function normalize(data) {
            const min = Math.min(...data);
            const max = Math.max(...data);
            return data.map(x => (x - min) / (max - min));
        }
        
        // 初始化图表
        function initChart() {
            const initialData = generateData(50);
            
            scalingChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: '原始数据',
                        data: initialData.map((value, index) => ({x: index, y: value})),
                        backgroundColor: 'rgba(54, 162, 235, 0.5)',
                        borderColor: 'rgba(54, 162, 235, 1)',
                        pointRadius: 5
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: '数据点索引'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: '数值'
                            }
                        }
                    }
                }
            });
        }
        
        // 事件监听
        document.getElementById('standardizeBtn').addEventListener('click', function() {
            const currentData = scalingChart.data.datasets[0].data.map(point => point.y);
            const standardizedData = standardize(currentData);
            
            scalingChart.data.datasets[0].data = standardizedData.map((value, index) => ({x: index, y: value}));
            scalingChart.data.datasets[0].label = '标准化后数据';
            scalingChart.update();
        });
        
        document.getElementById('normalizeBtn').addEventListener('click', function() {
            const currentData = scalingChart.data.datasets[0].data.map(point => point.y);
            const normalizedData = normalize(currentData);
            
            scalingChart.data.datasets[0].data = normalizedData.map((value, index) => ({x: index, y: value}));
            scalingChart.data.datasets[0].label = '归一化后数据';
            scalingChart.update();
        });
        
        document.getElementById('resetBtn').addEventListener('click', function() {
            const range = parseInt(document.getElementById('dataRange').value);
            const newData = generateData(range);
            
            scalingChart.data.datasets[0].data = newData.map((value, index) => ({x: index, y: value}));
            scalingChart.data.datasets[0].label = '原始数据';
            scalingChart.update();
        });
        
        document.getElementById('dataRange').addEventListener('input', function() {
            const range = parseInt(this.value);
            const newData = generateData(range);
            
            scalingChart.data.datasets[0].data = newData.map((value, index) => ({x: index, y: value}));
            scalingChart.data.datasets[0].label = '原始数据';
            scalingChart.update();
        });
        
        // 初始化
        window.onload = initChart;
    </script>
</body>
</html>