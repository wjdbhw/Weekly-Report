## （零）目录 
 78-134，152-199节。  

### APIs部分
78. APIs-day1-web APIs阶段课程安排
79. APIs-day1-声明变量const优先
80. APIs-day1-DOM树和DOM对象
81. APIs-day1-获取DOM元素
82. APIs-day1-DOM修改元素内容以及年
83. APIs-day1-DOM修改元素常见属性以
84. APIs-day1-通过style修改样式属性
85. APIs-day1-通过类名修改样式
86. APIs-day1-通过classList修改样式
87. APIs-day1-随机轮播图案例-上
88. APIs-day1-随机轮播图案例-下
89. APIs-day1-获取设置表单的值
90. APIs-day1-H5自定义属性-data
91. APIs-day1-定时器-间歇函数
92. APIs-day1-用户倒计时效果
93. APIs-day1-综合案例-轮播图定时版
94. APIs-day2-事件监听以及案例
95. APIs-day2-随机点名案例
96. APIs-day2-事件监听版本以及鼠标事件
97. APIs-day2-轮播图完整版-上集
98. APIs-day2-轮播图完整版-下集
99. APIs-day2-焦点事件以及小米搜索框
100. APIs-day2-键盘事件以及发布评论案例
101. APIs-day2-事件对象event以及常见
102. APIs-day2-回车发布评论案例
103. APIs-day2-环境对象this以及回调函数
104. APIs-day2-今日综合案例-tab切换
105. APIs-day3-表单全选反选案例
106. APIs-day3-事件流、事件捕获、事件
107. APIs-day3-事件解绑、mouseover和
108. APIs-day3-事件委托
109. APIs-day3-事件委托版本tab栏切换
110. APIs-day3-阻止元素默认行为
111. APIs-day3-页面加载事件和页面滚动
112. APIs-day3-小兔鲜显示导航和返回顶
113. APIs-day3-client家族和offset家族
114. APIs-day3-仿京东滑动以及bilibili导
115. APIs-day3-综合案例-电梯导航案例
116. APIs-day3-综合案例-电梯导航案例
117. APIs-day4-日期对象的使用
118. APIs-day4-时间戳的使用
119. APIs-day4-倒计时案例的制作
120. APIs-day4-查找DOM节点
121. APIs-day4-增加节点以及学成在线案例
122. APIs-day4-克隆节点和删除节点
123. APIs-day4-M端事件
124. APIs-day4-swiper插件的使用
125. APIs-day4-今日综合案例-学生信息
126. APIs-day4-今日综合案例-学生信息
127. APIs-day5-BOM和延迟函数setTimeout
128. APIs-day5-事件循环eventloop
129. APIs-day5-location对象
130. APIs-day5-navigator对象和histroy
131. APIs-day5-本地存储localstorage
132. APIs-day5-本地存储处理复杂数据类型
133. APIs-day5-综合案例-读取本地存储
134. APIs-day5-数组map和join方法//



135. APIs-day5-综合案例-渲染模块制作
136. APIs-day5-综合案例-录入模块制作
137. APIs-day5-综合案例-删除模块制作
138. APIs-day6-正则表达式使用
139. APIs-day6-元字符之边界符
140. APIs-day6-元字符之量词
141. APIs-day6-元字符之字符类
142. APIs-day6-预定义类以及修饰符和替换
143. APIs-day6-今日综合案例-注册页面-
144. APIs-day6-今日综合案例-注册页面-
145. APIs-day6-综合案例-注册页面-验证
146. APIs-day6-综合案例-注册页面-我同
147. APIs-day6-阶段案例-登录页制作
148. APIs-day6-阶段案例-首页制作
149. APIs-day7-实战案例-放大镜效果-鼠
150. APIs-day7-实战案例-放大镜效果-鼠
151. APIs-day7-实战案例-放大镜效果-大

### JS进阶部分
152. JS进阶-day1-JavaScript进阶阶段安排
153. JS进阶-day1-作用域和作用域链
154. JS进阶-day1-JS垃圾回收机制以及算法
155. JS进阶-day1-JS闭包
156. JS进阶-day1-变量和函数提升
157. JS进阶-day1-函数剩余参数和展开运
158. JS进阶-day1-ES6箭头函数的使用
159. JS进阶-day1-数组解构
160. JS进阶-day1-对象解构
161. JS进阶-day1-forEach遍历数组
162. JS进阶-day1-渲染商品案例
163. JS进阶-day1-综合案例-筛选商品案例
164. JS进阶-day2-今日内容和创建对象方式
165. JS进阶-day2-构造函数
166. JS进阶-day2-new 实例化执行过程
167. JS进阶-day2-实例成员和静态成员
168. JS进阶-day2-基本包装类型
169. JS进阶-day2-Object静态方法
170. JS进阶-day2-数组reduce累计方法
171. JS进阶-day2-数组find、every和转换
172. JS进阶-day2-字符串常见方法
173. JS进阶-day2-渲染赠品案例
174. JS进阶-day2-综合案例-购物车案例
175. JS进阶-day2-综合案例-购物车案例
176. JS进阶-day2-综合案例-购物车案例
177. JS进阶-day3-今日内容和两种编程思想
178. JS进阶-day3-构造函数实现封装以及
179. JS进阶-day3-原型对象prototype
180. JS进阶-day3-数组扩展案例-求最大
181. JS进阶-day3-constructor属性以及应用
182. JS进阶-day3-对象原型__proto__
183. JS进阶-day3-原型继承
184. JS进阶-day3-原型链以及instanceof
185. JS进阶-day3-综合案例-模态框构造
186. JS进阶-day3-综合案例-open方法封装
187. JS进阶-day3-综合案例close封装以
188. JS进阶-day4-今日内容和浅拷贝
189. JS进阶-day4-递归函数
190. JS进阶-day4-深拷贝实现
191. JS进阶-day4-利用lodash和JSON实
192. JS进阶-day4-异常处理-throw和try
193. JS进阶-day4-普通函数和箭头函数的
194. JS进阶-day4-call方法改变this指向
195. JS进阶-day4-apply方法
196. JS进阶-day4-bind方法以及总结
197. JS进阶-day4-什么是防抖以及底层实现
198. JS进阶-day4-什么是节流以及底层实
199. JS进阶-day4-节流综合案例-记录视
200. JavaScript核心与进阶大结局

## （一）基础语法
### 一、相关概念
1. 定义：JavaScript 是一种运行在客户端（浏览器）的编程语言，作用有 网页监听与特效、表单验证、数据交互、服务端编程 (node.js)
2. 组成：ECAMScript（基础语法） + Web APIs（DOM + BOM）
3. 权威网站：引擎直接搜索MDN
4. 书写位置：行内（在别的标签内直接写，vue中才这样写）+内部（写在紧挨着</body>的上方，其实可以写在任何想写的地方）+外部（以.js结尾的文件，用script标签内src属性引入，依旧双标签、放在\body正上面，且两个标签间不能写代码）
5. 单行注释：//  快捷键：ctrl + /

块注释：/* */  快捷键：shift + alt + A  

6. 结束符是英文分号; 按照团队要求统一写或不写。

### 二、输入输出
1. 输入语法：prompt('请输入')  显示一个对话框，上方是提示语，下方输入
2. 输出语法：document.write('向body内输出内容，如果是标签会被解析成网页元素')、alert（'对话框'）、console.log（'控制台'）直接输log，输出多个时用逗号分隔
3.  执行顺序：按照html文档流执行JS代码，alert和prompt会跳过渲染先被执行

### 三、变量
1. 字面量：计算机内用于描述事物的量
2. 变量：存储数据的容器，起名要遵循小驼峰命名法，  

声明：let 变量名，不可多次声明同一变量，建议一行只声明一个变量

赋值：变量名 = 字面量。<u>弱类型说明一个变量名可以存储不同类型的数据。（数组也行，好乱啊）</u>

初始化：声明的同时直接完成赋值

var现在不用了。

3. 数组：将一组数据存储在单个变量名下

let 数组名 = [ ]，可以存储任何类型的数据

属性：length

4. 常量：使用const不用let声明的变量，声明的时候必须赋初值，不能重新
5. 数据类型

基本数据类型：number，string，boolean，undefined（ 只声明不赋值直接输出就是undefined，可以用于检测有无数据传入），null（ 赋值了，但是内容为空。视作尚未创建的对象）

引用数据类型：object

NaN 代表一个计算错误。它是不正确或未定义的数学操作的结果  ， 任何对 NaN 的操作都会返回 NaN

string 单引号（ ''） 、双引号（ ""）或反引号( ` ) 包裹的数据都叫字符串 ，推荐用<font style="color:#DF2A3F;">双引号</font>。单双引号都必须成对使用  、二者可以互相嵌套，但是不以自已嵌套自已  ， 可以使用转义符 \输出它们。输出含字符串时+表示拼接。<font style="color:#DF2A3F;">模板字符串：</font>字符串用反引号引起，内部的变量用${}包裹即可正常输出。

控制台输出中，数字和布尔为蓝色字符串和undefined为灰。typeof作为运算符直接跟变量或作为函数加个括号都可以返回变量的类型，一般直接写

6. 类型转换

使用表单、prompt 获取过来的数据默认是字符串类型的  

隐式转换：

有字符串的加法 “” + 1 ，结果是 “1”（<u>二元运算符</u>）

（+号作为<font style="color:#DF2A3F;">正号</font>时是<u>一元</u>运算符，会将字符串转换为数字，所以当有一个纯数字组成的字符串想转化为数字时，直接+字符串即可。）

减法 - （和除了+之外的其他算术运算符）只能用于数字，它会使空字符串 "" 转换为 0、纯数字字符串自动转换为数字。

null 经过数字转换之后会变为 0、undefined 经过数字转换之后会变为 NaN，NaN的所有操作都得到NaN



显式转换为数字： <font style="color:#DF2A3F;">Number(数据)</font> 转成数字。如果字符串内容开头是非数字，转换失败，结果为NaN，它也是number类型的数据，代表非数字。如果开头是数字会转换至非数字处结束；<font style="color:#DF2A3F;">parseInt(数据)</font>只保留整数；<font style="color:#DF2A3F;">parseFloat(数据)</font>可以有小数

显式转换为字符： <font style="color:#DF2A3F;">String(数据)</font>；<font style="color:#DF2A3F;">变量.toString(进制) </font> （先转为指定进制，再转为字符串）

显式转换为布尔： ‘’、0、undefined、null、false、NaN 转换为布尔值后都是false, 其余则为 true  

## （二）语句
1. 运算符

①后面 i++ 后置自增会使用相对较多,并且都是单独使用 。它的效果跟前置没有区别。

② ===表示左右两边类型和值都相等，推荐使用这个判断是否相等；!==：左右两边是否不全等

③ 字符串是从左向右依次比较字符的ASCII码；NaN不等于任何值，包括它本身 ；尽量不要比较小数，有精度问题；不同类型之间比较会发生隐式转换，最终把数据隐式转换转成number类

④ 一元运算符里面的逻辑非优先级很高；逻辑与比逻辑或优先级高  

2. 语句

表达式是可以被求值的代码，可以写在赋值语句的右侧；

语句是一段可以执行的代码，不一定有值。

 也可以把表达式理解为表达式语句，因为它是在计算结果，但不是必须的成分

3. 分支：if、三元、switch（此时必须全等于该值，一般搭配break使用）
4. 循环

ps：断点调试

调试界面开发者工具中 sources栏 后选择代码文件，在某句代码上加的标记就叫断点，当程序执行到这句有标记的代码时会暂停下来  

5. 数组

定义一个空数组可以等号右边写空的中括号。可以直接输出数组名。

属性：length

方法：

【增】 arr.unshift(新增的内容) <font style="color:#DF2A3F;">arr.push</font>(新增的内容) 分别增至数组的首尾 ，都会返回数组的新长度。同时加多个时用逗号分隔。

【删】arr.shift()  arr.pop() 分别删首尾，每次一个，返回被删的元素；arr.splice(起始下标,删除的个数） 省略删除个数默认删到最后

【排序】sort默认升序

降序：arr.sort(function (a, b) { return b - a })

6. 函数

① 声明：小驼峰、常用动词（can判断是否可执行、has判断是否含、is判断是否为、get获取、set设置、load加载）。用function关键字声明，提倡先声明再调用。

② 不输入的参数默认为 undefined，形参可以直接用等号赋予默认值

③ return 后立即结束当前函数，后面的数据不要换行写。return后面不接数据或者函数内不写return，返回值是 undefined。用数组返回多个值。

④ 两个相同的函数后面的会覆盖前面的；如果形参过多会自动填上undefined、实参过多时多余的实参会被忽略

⑤  函数内部变量不声明直接赋值，约等于全局变量看，不推荐；形参为函数的局部变量。 

同名变量访问原则：能够访问到的情况下，从当前作用域找起，向上逐层查找，先局部再全局的“就近”

⑥ 匿名函数：没有名字的函数, 无法直接使用。

【函数表达式】 将匿名函数赋值给一个变量，并且通过变量名称进行调用。此时变量跟函数名的地位差不多。唯一的区别是<font style="color:#DF2A3F;"> 必须</font> 先声明再使用

【立即执行函数】 避免全局变量之间的污染，多个立即执行函数之间用分号隔开

( function () { 函数体 }) ( ) ；<font style="color:#8A8F8D;">单个可以不加分号</font>

⑦  逻辑运算符里的短路同c++。可以通过  x = x || 0  的方式形成参数的默认值

7. 对象

无序的数据的集合（数组有序）

① 用花括号声明，属性+方法。

属性名与值成对出现，用:分隔；多个属性之间用,分隔；属性名可以由单双引号引起，一般情况都省略，但当属性名中有空格、中横线等特殊字符时必须引起，此时访问这个属性也不能用普通的方法<font style="color:#8A8F8D;">（属性尽量不要叫name，之后有用）</font>

<font style="color:#8A8F8D;"> </font>方法由方法名和函数构成，分隔和引起方式同属性

② 在对象中增加新属性：直接写就完了，对象名.新属性=新值

删除对象中属性 ：delete 对象名.属性名（了解）

对于多测属性或含-的属性， **对象[‘属性’]**  格式访问，单双引号都行。 

[]里的值不加引号时为变量解析，一般直接用点访问,，需要解析变量的时候使用 []

③ 遍历对象的元素

for ( let k in obj ){

consloe.log( k )

console.log( obj[ k ] )

}

k 是变量, 所以必须使用 [ ] 语法解析

<font style="color:#DF2A3F;">k 是对象的属性名，</font><u><font style="color:#DF2A3F;">对象名[k] </font></u><font style="color:#DF2A3F;">是属性值  </font>

④ 内置对象Math

内置对象是JavaScript内部提供的对象，含各种属性和方法

Math对象提供了一系列数学运算的方法，有：

**random**：生成0-1之间的随机数（包含0不包括1）

ceil：向上取整、 floor：向下取整 

max：找最大数、min：找最小数

**pow**：幂运算 、**abs**：绝对值  

在线文档：[https://www.w3school.com.cn/js/jsref_obj_math.asp](https://www.w3school.com.cn/js/jsref_obj_math.asp)

主要看随机数函数， 返回一个属于[0, 1）的随机小数。

如果想要生成0-10内的随机整数：Math.floor(Math.random() * (10 + 1))  

生成N-M之间的随机整数： Math.floor(Math.random() * (M - N + 1)) + N  

得到数组的随机索引号：Math.floor(Math.random()*arr.lrngth))

8. 术语

| 术语 | 解释 | 举例 |
| --- | --- | --- |
|  关键字   |  在JavaScript中有特殊意义的词汇   |  let、var、function、if、else |
|  保留字   |  在目前的JavaScript中没意义，但未 来可能会具有特殊意义的词汇   |  int、short、long、char   |
|  标识（标识符）   |  变量名、函数名的另一种叫法   |  无   |
|  表达式   |  能产生值的代码，一般配合运算符出现   |  10 + 3、age >= 18   |
|  语句   |  一段可执行的代码   |  If () for()   |


9. 内存

简单数据类型=值类型，变量的数据直接在栈空间内存放；

用new关键字创建出来的对象（如Object、Array、Date）都存放在堆空间，栈空间（即变量本身）存放的是其在堆空间内的地址（引用）



## （三）Ajax
### 一、原生 AJAX
1. **AJAX基础概念**

全称：Asynchronous JavaScript And XML（异步的 JS 和 XML）

核心能力：在浏览器中向服务器发送**异步请求**，最大优势是**无刷新获取数据**

****不是新编程语言，而是将现有标准组合使用的新方式

2. **XML 简介**

定义：可扩展标记语言，用来传输和存储数据；html用来呈现数据。现在被 JSON 取代（更简洁、容易解析）

与html的区别：html包含预定义标签（`<div>`等定义好的标签），用于展示页面结构；XML没有，所有标签都可以随便自定义，仅用于描述数据。  
学生数据（name="孙悟空"；age=18；gender="男"）

| XML | `<student><name>孙悟空</name><age>18</age></student>` |
| --- | --- |
| JSON | `{"name":"孙悟空","age":18}` |


3. **AJAX 的特点**

【优点】

① 不刷新页面也可与服务器端通信；  
② 可根据用户事件（如点击、输入）更新部分页面内容。

【缺点】

① 没有浏览历史与回退；  
② 存在跨域问题；  
③ SEO（搜索引擎优化）不友好（数据动态加载，搜索引擎难以抓取）。

4. **http**

hypertext transport protocol超文本传输协议。规定浏览器和万维网服务器之间互相通信的规则。

【请求】浏览器向服务端申请数据的代码叫做请求报文，重点是格式与参数。

行：请求类型，多用get和post / url路径 / 协议版本，一般用1.1 

头：格式为名字+冒号+空格+值

空行

体：get请求的请求体为空

【响应】返回的结果叫响应报文

行：协议版本 / 响应状态码（200表示成功，404无法找到，403被禁止，401未授权等） / 响应状态字符串（200对应OK，是对应的）

头：与请求头格式相同

空行

体：主要返回结果，是一个html内容

【在网页中查看报文】f12（检查）->网络->刷新后即可看到所有请求行和头，当为get请求有url参数的时候query string解析请求行的参数，form data请求体，响应体在response

5. **express框架**

cmd中node express文件.js后配置成功，[http://127.0.0.1:8000](http://127.0.0.1:8000/)有响应。它相当于是服务器，可以与前端ajax做交互





6. ** AJAX 的使用**

【核心对象】

`XMLHttpRequest`：AJAX 的所有操作均通过该对象实现。

【使用步骤】

① **创建 XMLHttpRequest 对象**  

```javascript
var xhr = new XMLHttpRequest();
```

② **设置请求信息**  

+ 基础配置：`xhr.open(method, url)`（method 为请求方式，如 GET/POST；url 为请求地址）；
+ 可选配置（POST 请求需设置）：`xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')`（指定请求体格式）。

③ **发送请求**  

+ GET 请求：`xhr.send()`（无需传参）；
+ POST 请求：`xhr.send(body)`（body 为请求参数，如 `name=zhangsan&age=20`）。

④ **接收响应**  
通过 `onreadystatechange` 事件监听请求状态，获取响应数据：

```javascript
xhr.onreadystatechange = function () {
  // 当请求完成且响应成功（状态码 200）时处理数据
  if (xhr.readyState === 4 && xhr.status === 200) {
    var textData = xhr.responseText; // 接收文本格式数据
    var xmlData = xhr.responseXML;   // 接收 XML 格式数据（已极少用）
    console.log(textData);
  }
}
```

【解决 IE 缓存问题】

问题：IE 浏览器会缓存 AJAX 请求结果，后续相同 URL 的请求会直接加载缓存，不发送新请求。

解决方案：修改 URL 地址（添加时间戳，确保每次请求 URL 唯一）：

```javascript
xhr.open("get", "/testAJAX?t=" + Date.now()); // Date.now() 生成当前时间戳
```

【AJAX 请求状态（xhr.readyState）】

| 状态值 | 描述 |
| --- | --- |
| 0 | XMLHttpRequest 实例已创建，但 `open()` 未调用 |
| 1 | `open()` 已调用，但 `send()` 未调用（可设置请求头） |
| 2 | `send()` 已执行，已接收响应头和状态码 |
| 3 | 正在接收服务器返回的响应体数据（部分数据可用） |
| 4 | 响应已完全接收（或请求失败） |


### 二、jQuery 中的 AJAX
jQuery 封装了原生 AJAX 语法，简化请求代码，核心提供 `get` 和 `post` 两种请求方式。

1. **get 请求**
+ **语法**：`$.get(url, [data], [callback], [type])`
+ **参数说明**：

| 参数 | 类型 | 描述 |
| --- | --- | --- |
| url | String | 必选，请求的 URL 地址 |
| data | Object/String | 可选，请求携带的参数（如 `{name: 'lisi', age: 22}` 或 `name=lisi&age=22`） |
| callback | Function | 可选，请求成功后的回调函数（参数为响应数据） |
| type | String | 可选，指定响应数据格式（如 `json`、`text`、`html`，默认自动识别） |


+ **示例**：

```javascript
$.get("/getUser", {id: 123}, function (data) {
  console.log("用户信息：", data);
}, "json");
```

2. **post 请求**
+ **语法**：`$.post(url, [data], [callback], [type])`
+ **参数说明**：与 `$.get()` 完全一致（仅请求方式不同）。
+ **示例**：

```javascript
$.post("/addUser", {name: "wangwu", age: 25}, function (res) {
  console.log("添加结果：", res);
}, "text");
```



### 三、跨域
1. **同源策略**

**定义**：由 Netscape 提出的浏览器安全策略，限制不同源的页面访问彼此资源。

**同源判定**：协议、域名、端口号必须**完全相同**，否则即为跨域。

示例：`http://localhost:8080` 与以下地址的对比：  
① `https://localhost:8080`：协议不同（跨域）；  
② `http://www.baidu.com:8080`：域名不同（跨域）；  
③ `http://localhost:8081`：端口不同（跨域）；  
④ `http://localhost:8080/index.html`：同源（协议、域名、端口相同）。

2. **跨域解决方案**

##### 2.1 JSONP
**定义**：JSON with Padding，非官方跨域方案，仅支持 **GET 请求**。

**原理**：利用 `<script>` 标签天生支持跨域的特性（如引入外部 CDN 脚本），通过动态创建 `<script>` 发送请求。

**使用步骤**：  
① **客户端**：动态创建 `<script>`，指定请求 URL 和回调函数；

```javascript
// 1. 创建 script 标签
var script = document.createElement("script");
// 2. 设置 src（包含回调函数名 callback=abc）
script.src = "http://localhost:3000/testAJAX?callback=abc";
// 3. 定义回调函数（接收服务器返回的数据）
function abc(data) {
  alert("服务器返回：" + data.name); // 输出 "孙悟空"
}
// 4. 将 script 加入页面（触发请求）
document.body.appendChild(script);
```

② **服务器端**：接收回调函数名，返回“回调函数(数据)”格式的响应；

```javascript
// 以 Express 框架为例
router.get("/testAJAX", function (req, res) {
  // 1. 获取客户端传递的回调函数名
  var callbackName = req.query.callback;
  // 2. 构造要返回的数据
  var data = {name: "孙悟空", age: 18};
  // 3. 返回 "abc({...})" 格式的响应（客户端会执行 abc 函数）
  res.send(callbackName + "(" + JSON.stringify(data) + ")");
});
```

+ **jQuery 中的 JSONP**：简化客户端代码，无需手动创建 `<script>`，只需将 `callback` 设为 `?`（jQuery 自动生成回调函数）；

```html
<script src="./jquery-1.12.3.js"></script>
<script>
  $("#btn").click(function () {
    // 请求豆瓣电影接口（跨域）
    $.getJSON("http://api.douban.com/v2/movie/in_theaters?callback=?", function (data) {
      // 遍历数据，渲染电影列表
      var subjects = data.subjects;
      subjects.forEach(function (movie) {
        $("#list").append(`<li>${movie.title}<br><img src="${movie.images.large}"></li>`);
      });
    });
  });
</script>

```

##### 2.2 CORS
**定义**：Cross-Origin Resource Sharing（跨域资源共享），**官方跨域方案**，支持 GET/POST 等所有请求方式，无需客户端额外操作，仅需服务器配置。

**原理**：服务器通过设置响应头 `Access-Control-Allow-Origin`，告知浏览器“允许该源跨域访问”，浏览器收到后放行响应。

**使用步骤**：仅需在服务器端设置响应头；

```javascript
// 以 Express 框架为例
router.get("/testAJAX", function (req, res) {
  // 配置跨域：允许指定源访问（如 http://127.0.0.1:3000）
  // res.set("Access-Control-Allow-Origin", "http://127.0.0.1:3000");
  // 配置跨域：允许所有源访问（开发环境可用，生产环境不推荐）
  res.set("Access-Control-Allow-Origin", "*");
  // 返回响应数据
  res.send("跨域请求成功！");
});
```

**参考文档**：[MDN - CORS](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS)

## （四）Web APIs
### 一、基础知识
1. 变量声明

 优先使用const声明变量，发现它要被修改时再改为let  

（引用数据类型如数组、对象存的不是值，const声明后依旧可以改变其内容。但是要注意改变的方法：可以直接改元素，但是不能给整个变量赋值

```javascript
const names = []
names = [1, 2, 3]
const obj = {}
obj = {
    uname: "用户名"
}
```

```javascript
const names = []
names[0] = 1
const obj = {}
obj.name = "用户名"
```

）

2. API作用：使用js操作html和浏览器。分类：DOM、BOM
3. DOM树：HTML文档的树状结构呈现叫做文档树或DOM树，直观展现标签之间的关系（如`html`是根节点，包含`head`和`body`子节点）。

**<font style="color:#F1A2AB;">ps.</font>**<font style="color:#F1A2AB;">   console.dir（对象）可以直接在控制台输出对象的所有内容</font>

### 二、DOM事件
1. <font style="color:#2F4BDA;">DOM对象</font>

JS中，浏览器根据html标签生成的对象。DOM其实是统称，核心包含两类对象：  

核心对象：`document`，<font style="color:rgba(0, 0, 0, 0.85);">代表整个HTML文档</font>，是DOM的具体实现载体。

文档树中的节点对象：包括元素节点（`<font style="color:rgb(0, 0, 0);">Element</font>`<font style="color:rgb(0, 0, 0) !important;">类，HTML元素节点的直接父类是</font>`<font style="color:rgb(0, 0, 0);">HTMLElement</font>`<font style="color:rgb(0, 0, 0) !important;">，不同具体 HTML 元素对应其专属子类，如</font>`<font style="color:rgb(0, 0, 0);"><div></font>`<font style="color:rgb(0, 0, 0) !important;">对应</font>`<font style="color:rgb(0, 0, 0);">HTMLDivElement</font>`）、文本节点（`Text` 对象）、属性节点（`Attr` 对象）、注释节点（`Comment` 对象）等，它们构成了 DOM 树的具体结构。

2. <font style="color:#2F4BDA;">获取DOM对象</font>

操作某个标签先要定位对象。方法：按CSS选择器获取

**选择匹配的第一个元素 ：**`document.querySelector('css选择器')`

参数: CSS选择器<font style="color:#F1A2AB;">字符串</font>  

返回值：匹配的第一个元素所转换成为的对象（dom对象的核心子类，专门对应元素节点），未匹配返回`null`。

**选择匹配的多个元素：**`document.querySelectorAll('css选择器')`

参数同上，返回匹配的所有匹配的元素转换成的对象 的集合（NodeList），有点类似于数组，有索引，但是不能使用pop等方法。

3. <font style="color:#2F4BDA;">操作元素</font>

**-----操作元素内容： 比较喜欢用innerHTML属性；值都是带引号的字符串-----**

| 方式 | 特点 | 示例 |
| --- | --- | --- |
| 元素对象.innerText | 不解析标签，仅显示纯文本 | `info.innerText = '纯文本'` |
| 元素对象.innerHTML | 解析标签，支持嵌套多标签 | `info.innerHTML='<strong>加粗</strong>'` |


**-----操作元素属性：**前三个是标签自带的，叫标准属性，可以直接用点语法操作-----

**① 常用固有属性**（如src、href、title等）

直接给“元素对象.属性名”赋值修改，<font style="color:#8A8F8D;">eg.</font>`<font style="color:#8A8F8D;">img.src = './new.jpg'</font>`

**② 样式属性**

【行内样式】通过“元素.style.属性名”修改，有连接符的属性名要改写为小驼峰，有单位的要加单位   eg.`box.style.marginTop = '15px'` 。  

【修改类名】给这个对象对应的元素一个新的类名。

`~~<font style="color:#8A8F8D;">元素.className</font>~~`~~<font style="color:#8A8F8D;">：直接赋值，但覆盖原来的类名，不覆盖比较麻烦</font>~~

`元素.classList`：提供`add`追加、`remove`删除、`toggle`更换这三个方法，推荐使用，<font style="color:#8A8F8D;">eg.</font>`<font style="color:#8A8F8D;">box.classList.add('active')</font>`

**③ 表单属性**（disabled、checked、value等）

有取值的属性也是<font style="color:#F1A2AB;"> 元素对象.属性名</font> 直接修改；直接添加或或移除的属性，用布尔值表示是否存在，特指disabled、checked、selected等

**④ 自定义属性**

自定义属性是H5新增、标签上以`data-属性名`格式定义的属性。dom对象内这些属性存储在dataset这个属性内，由于存着多个，它本身也算是个对象，因此通过“<font style="background-color:#FBE4E7;">元素.dataset.属性名</font>”访问/修改，<font style="color:#8A8F8D;">eg.</font>`<font style="color:#8A8F8D;">div.dataset.id = '2'</font>`（修改data-id的值为2）。

4. <font style="color:#2F4BDA;">定时器：间歇函数</font>

**ps.箭头函数**

<font style="color:rgb(0, 0, 0);background-color:rgba(0, 0, 0, 0.06);">(参数) => { 函数体 }</font>**，**单参数可省略括号；<font style="color:rgba(0, 0, 0, 0.85);">单语句可省大括号和 return。如要起名，将其赋值给一个变量即可。特点：无自己的this、不能作构造函数（</font>`<font style="color:rgb(0, 0, 0);">this</font>`<font style="color:rgb(0, 0, 0) !important;">表示函数执行时，调用此函数的对象，用它可以</font><font style="color:rgba(0, 0, 0, 0.85);">直接操作该对象）</font>

```javascript
function add(a, b) { return a + b; }// 普通函数
const add = (a, b) => a + b;// 箭头函数
```

**开启间歇函数**  
语法：[<font style="color:#F1A2AB;">let timer =] setInterval (回调函数, 间隔毫秒数) </font>，作用是每隔指定时间重复执行回调函数。  
<font style="color:#8A8F8D;">eg.</font>`<font style="color:#8A8F8D;">let timer = setInterval(() => { console.log('每1秒执行'); }, 1000)</font>`<font style="color:#8A8F8D;">。</font>

**关闭间歇函数**  
语法：`clearInterval(timer)`，需传入开启时保存的间歇函数`timer`，停止重复执行。

```javascript
setTimeout(() => {
  clearInterval(timer);//这个timer接上面的例子
}, 3000);//定时执行，3s后关闭timer
```

5. <font style="color:#2F4BDA;">事件监听</font>

**【定义】**检测页面中特定事件（如点击、输入），事件触发后自动执行预设的函数，也叫**事件绑定or注册。**

**【三要素】**  **事件源**（被触发的DOM对象，如按钮）、**事件类型**（具体的触发行为，如`click`点击）、**处理函数**（事件触发后执行的函数）。

**【语法】**（推荐使用L2事件监听）：`事件源.addEventListener('事件类型', 处理函数)`

```javascript
const btn = document.querySelector('button');
btn.addEventListener('click', () => {
  alert('点击触发');
});
```

**【版本区别**】

L0事件（`事件源.on事件 = 函数`）后注册的事件会覆盖前一个，示例：`btn.onclick = () => { alert('仅执行最后一个'); }`。

L2事件（`addEventListener`）可多次注册同一事件不会覆盖，还支持事件捕获/冒泡，更灵活。

6. <font style="color:#2F4BDA;">常见事件类型</font>

| 类型 | 具体事件 | 说明 |
| --- | --- | --- |
| 鼠标事件 | click、mouseenter、mouseleave | 点击、鼠标进入元素、鼠标离开元素（mouseenter/mouseleave无冒泡） |
| 焦点事件 | focus、blur | 元素获得焦点（如点击输入框）、元素失去焦点（如点击输入框外） |
| 键盘事件 | keydown、keyup | 键盘按键按下、键盘按键抬起（可通过`e.key`判断具体按键） |
| 文本事件 | input | 输入框（如input、textarea）内容实时变化时触发 |


其他事件

【页面加载事件】

        * `load`（`window`）：所有资源（图片、CSS）加载完触发。
        * `DOMContentLoaded`（`document`）：DOM加载完就触发（无需等图片，更快）。

【页面滚动事件】`scroll`（`window`），用`document.documentElement.scrollTop`获取滚动距离。

【页面尺寸事件】`resize`（`window`），用`document.documentElement.clientWidth`获取窗口宽度。

7. <font style="color:#2F4BDA;">事件对象</font>

**【定义】**事件触发时，浏览器自动生成的“信息集合”，包含事件相关数据（如鼠标位置、按键信息），是事件处理函数的第一个参数，常用`e`命名。

**【常用属性**】

    - `e.type`：获取当前触发的事件类型（如`click`、`keydown`）。  
    - `e.clientX / e.clientY`：获取鼠标相对于浏览器窗口的坐标位置。  
    - `e.offsetX / e.offsetY`：获取鼠标相对于事件源（触发事件的元素）的坐标位置。  
    - `e.key`：获取触发键盘事件时按下的具体按键（如`Enter`、`a`）。

```javascript
const input = document.querySelector('input');
input.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    console.log('发布：', input.value);
  }
});
```

8. <font style="color:#2F4BDA;">环境对象this</font>

**【规则】**函数执行时，`this`指向“调用该函数的对象”；在事件处理函数中，`this`固定指向事件源（触发事件的DOM元素）。

```javascript
const btn = document.querySelector('button');
btn.addEventListener('click', function() {
  this.style.color = 'red'; // this指向事件源btn，点击后按钮文字变红
});
```

9. <font style="color:#2F4BDA;">回调函数</font>

**【定义】**  
将函数A作为参数传递给函数B，当函数B执行到特定时机时，再调用函数A，此时函数A就是回调函数。常见于定时器、事件监听、异步操作中。

**<font style="color:#8A8F8D;">【示例】</font>**<font style="color:#8A8F8D;">  </font>

    - <font style="color:#8A8F8D;">定时器中的回调函数：</font>`<font style="color:#8A8F8D;">setInterval(() => { console.log('回调执行'); }, 1000)</font>`<font style="color:#8A8F8D;">（箭头函数是传给setInterval的回调函数）。  </font>
    - <font style="color:#8A8F8D;">事件监听中的回调函数：</font>`<font style="color:#8A8F8D;">btn.addEventListener('click', () => { alert('回调执行'); })</font>`<font style="color:#8A8F8D;">（箭头函数是传给addEventListener的回调函数）。</font>
10. <font style="color:#2F4BDA;">事件流</font>

【定义】事件触发的完整流程，分两个阶段：

① 捕获阶段：从`document`（根）到事件源（从外到内），需给`addEventListener`第三个参数传`true`才触发（很少用）。

② 冒泡阶段：从事件源到`document`（从内到外），默认触发（`addEventListener`第三个参数为`false`或省略）。

```javascript
// 点击son，会依次触发son、father、document的click事件
const father = document.querySelector('.father');
const son = document.querySelector('.son');
document.addEventListener('click', () => alert('爷爷'));
father.addEventListener('click', () => alert('爸爸'));
son.addEventListener('click', () => alert('儿子'));
```

【阻止冒泡】`e.stopPropagation()`（避免事件影响父元素）。

【阻止默认行为】`e.preventDefault()`（如阻止链接跳转、表单提交）。

```javascript
const form = document.querySelector('form');
form.addEventListener('submit', (e) => {
  e.preventDefault(); // 阻止默认提交
});
```

11. <font style="color:#2F4BDA;">解绑事件</font>
+ L0方式：`事件源.on事件 = null`。
+ L2方式：`事件源.removeEventListener('事件类型', 命名函数)`（<font style="color:#df2a3f;">匿名函数无法解绑</font>）。

```javascript
function fn() { alert('点击'); }
const btn = document.querySelector('button');
btn.addEventListener('click', fn);
btn.removeEventListener('click', fn); // 解绑
```

12. <font style="color:#2F4BDA;">事件委托</font>

【原理】利用事件冒泡，给父元素注册事件，通过`e.target`找到真正触发事件的子元素。这样可以减少事件注册次数，提高性能（如给`ul`注册，处理所有`li`的点击）。

```javascript
const ul = document.querySelector('ul');
ul.addEventListener('click', (e) => {
  if (e.target.tagName === 'LI') { // 判断触发源是li
    e.target.style.color = 'pink';
  }
});
```

13. <font style="color:#2F4BDA;">元素尺寸与位置</font>

| 属性 | 作用 | 说明 |
| --- | --- | --- |
| `scrollTop/scrollLeft` | 元素被卷去的头部/左侧 | 可读写，配合滚动事件用 |
| `clientWidth/clientHeight` | 元素可见宽高 | 不含border、滚动条，只读 |
| `offsetWidth/offsetHeight` | 元素整体宽高 | 含border、padding，只读（隐藏元素为0） |
| `offsetTop/offsetLeft` | 元素相对于定位父级的位置 | 只读，无定位父级则相对于文档 |


14. <font style="color:#2F4BDA;">日期对象</font>
+ 实例化：
    - 当前时间：`const date = new Date()`。
    - 指定时间：`const date = new Date('2024-05-01')`。
    - 常用获取时间方法：

| 方法 | 说明 |
| --- | --- |
| `getFullYear()` | 四位年份 |
| `getMonth()` | 月份（0-11，需+1） |
| `getDate()` | 日期（1-31） |
| `getHours()/getMinutes()/getSeconds()` | 时/分/秒 |


```plain
- 时间戳：1970-01-01至今的毫秒数，用于倒计时（三种获取方式）：
```

```javascript
const date = new Date();
console.log(date.getTime()); // 方式1
console.log(+new Date()); // 方式2（推荐，支持指定时间）
console.log(Date.now()); // 方式3（仅当前时间）
```

15. <font style="color:#2F4BDA;">节点操作</font>

【DOM节点分类】元素节点（标签）、属性节点（如`class`）、文本节点（文字），重点关注元素节点。

【查找节点】

    - 父节点：`子元素.parentNode`（最近一级父节点）。
    - 子节点：`父元素.children`（仅元素节点，伪数组）。
    - 兄弟节点：`元素.nextElementSibling`下一个、`元素.previousElementSibling`上一个。

【增加节点】

    - 创建：`document.createElement('标签名')`，如`const li=document.createElement('li')`
    - 追加：`父元素.appendChild(新元素)`（追加到末尾）、`父元素.insertBefore(新元素, 参考元素)`（插入到参考元素前）。
    - 克隆：`元素.cloneNode(布尔值)`（`true`克隆后代，`false`仅克隆自身）。

【删除节点】`父元素.removeChild(子元素)`（必须通过父元素删除）。

16. <font style="color:#2F4BDA;">移动端事件</font>

| 事件 | 说明 |
| --- | --- |
| `touchstart` | 手指触摸到元素时触发 |
| `touchmove` | 手指在元素上滑动时触发 |
| `touchend` | 手指从元素上移开时触发 |


17. <font style="color:#2F4BDA;">JS插件（如Swiper轮播）</font>

【使用流程】引入插件CSS/JS → 写HTML结构 → 初始化插件（按官网文档配置）。

### 三、BOM事件
1. Window对象

【BOM核心】`window`是全局对象，`document`、`alert()`等都是其属性，调用时可省略`window`。

【延时函数（`setTimeout`）】

语法：`let timer = setTimeout(回调函数, 延迟毫秒数)`（仅执行一次）。

关闭：`clearTimeout(timer)`。

【JS执行机制】

单线程：同一时间只做一件事。

同步任务：主线程执行（如`console.log`）。

异步任务：放入任务队列（如定时器、事件），同步任务执行完后再执行。

2. 常用BOM对象：`location`地址栏

| 属性/方法 | 作用 |
| --- | --- |
| `href` | 获取/设置完整URL（如`location.href = 'https://baidu.com'`跳转） |
| `search` | 获取`?`后的参数（如`?name=123`） |
| `reload(true)` | 刷新页面（`true`强制刷新） |


```plain
- `navigator`（浏览器信息）：用`navigator.userAgent`检测设备（如判断移动端）。
- `history`（历史记录）：
    * `back()`：后退一页。
    * `forward()`：前进一页。
    * `go(数字)`：前进/后退指定页数（如`go(1)`前进，`go(-1)`后退）。
```

3. 本地存储

【特点】存储在浏览器，5M左右，刷新不丢失。

| 类型 | 生命周期 | 共享范围 |
| --- | --- | --- |
| `localStorage` | 永久（需手动删除） | 同一浏览器多窗口 |
| `sessionStorage` | 关闭窗口后消失 | 同一窗口 |


```plain
- 语法（以`localStorage`为例）：
```

```javascript
// 存储（仅存字符串）
localStorage.setItem('name', 'pink');
// 获取
console.log(localStorage.getItem('name'));
// 删除
localStorage.removeItem('name');
```

```plain
- 存储复杂数据（数组/对象）：需用`JSON.stringify()`转字符串，取用时用`JSON.parse()`转对象：
```

```javascript
const obj = { name: 'pink', age: 18 };
localStorage.setItem('obj', JSON.stringify(obj)); // 存
const newObj = JSON.parse(localStorage.getItem('obj')); // 取
```

### 四、正则表达式
1. 定义：匹配字符串中字符组合的模式，用于表单验证、敏感词过滤、字符串提取。
2. 语法
3. 定义规则：`const reg = /表达式/`（如`const reg = /前端/`）。
4. 检测：`reg.test(字符串)`（返回布尔值，是否匹配）。
5. 提取：`reg.exec(字符串)`（返回数组，匹配结果；无匹配返回`null`）。
6. 元字符
7. 边界符：`^`（行首）、`$`（行尾），一起用表示精确匹配（如`/^123$/`仅匹配“123”）。
8. 量词（指定重复次数）：

| 量词 | 说明 |
| --- | --- |
| `*` | 0次或多次 |
| `+` | 1次或多次 |
| `?` | 0次或1次 |
| `{n}` | 恰好n次 |
| `{n,}` | n次或更多 |
| `{n,m}` | n到m次（逗号无空格） |


9. 字符类：
    - `[abc]`：匹配a、b、c中任意一个。
    - `[a-z]`：匹配小写字母，`[A-Za-z0-9]`匹配字母数字。
    - `[^a-z]`：匹配非小写字母（`^`在中括号内表取反）。

预定义类：`\d`（0-9）、`\w`（字母/数字/下划线）、`\s`（空格）。

10. 修饰符
    - `i`：忽略大小写（如`/a/i`匹配“A”“a”）。
    - `g`：全局匹配（如替换所有敏感词）。
    - 示例（过滤敏感词）：

```javascript
let str = 'pink老师很牛';
str = str.replace(/牛/g, '**'); // 全局替换为**
console.log(str); // pink老师很**
```



综合案例（表单验证）

    - 用户名（6-16位字母/数字/下划线）：`/^[a-zA-Z0-9_-]{6,16}$/`。
    - 手机号：`/^1(3\d|4[5-9]|5[0-35-9]|6[567]|7[0-8]|8\d|9[0-35-9])\d{8}$/`。
    - 验证码（6位数字）：`/^\d{6}$/`。

