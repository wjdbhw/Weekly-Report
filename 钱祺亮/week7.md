<style>
    .pink{
        color : pink ;
        background : green ;
        text-align: center;
    }
</style>

# <p class="pink">何 EVA 周报</p>

> 1.（10.27）今天在看 mdn 的函数部分。在实现一个流氓 × 时发现了一个盲点，首先就是（kimi 又在说胡话了，当然不是）发现事件冒泡这种尤物，感觉这个暂时无法处理，然后就是之前以为如果有优先级更高的 css 标签，元素全盘就会使用，但是事实是在优先级没有提及的元素，他还是会遵循优先级更低，但是依旧包含这个属性的 css 标签。
>
> 2.没错，还是流氓二选一，关于一个函数加不加（）的问题：
>
> > - JS 赋值： onclick = 函数 （不要加 () ）。
> > - HTML 属性： onclick="函数()" 是字符串，浏览器帮你延迟执行.
> >   如果在 script 里，如果碰上带括号的函数，浏览器解析到这里就会直接运行，而如果是包含在 html 元素里的属性，就必须加上括号，不加的话就等于没传。
> >   （28 号回来说明，**内联事件处理器不要用**，哭）
>
> 3.（10.28）今天学习了计网的第一章，学习了事件冒泡，事件捕获和事件委托，事件处理器属性和内联事件处理器，临近考试，感觉没多少时间来练习了。
>
> > - 可以使用`stopPropagation()`来阻止事件冒泡，但是事件委托依赖于事件冒泡，所以说处理这段逻辑时要很谨慎。
> > - **事件委托**在父级层级太高，子元素事件类型差异过大，子元素阻止冒泡时不能够使用事件委托，在子类需要大量重复的事件监视器时，就可以用父类来绑定一个事件监视器，然后借助事件冒泡和`event.target()`来确定点击的子元素，然后只执行点击的最小的元素监视器调用的事件。
> > - **事件捕获**， 这东西我真不知道有什么存在的意义........（kimi 表示不想理我，呜呜呜）
>
> 4.（10.29）今天学习了计网的第二章，复习了计网的第一章，了解了协议，服务，物理层这些概念，还有物理层的实现过程与原理，TCP/IP 四层协议。学习了 js 对象，在对象属性上，js 有一个跟 cpp 和 java 很不同的点。
>
> > - js 可以类似于动态的对对象属性进行新增和修改，其中括号表示法可以动态的设置对象成员的值，还可以动态的设置成员的名字。`person[myDataName] = myDataValue;`类似于这种的。
> > - 在 cpp 和 java 里，不存在`person[变量名] = 值`这种用运行期字符串当场新增/覆盖字段的语法。
> >   两者都是静态类型语言，成员必须在编译期就写死，或者通过反射/映射机制绕路实现。
> > - 删除 DOM 节点
> >   > 1.  `remove（）`但是老旧的浏览器不支持
> >   > 2.  `removeChild()`,先找到他的爸爸，然后让他的爸爸把他杀死（有点不道德）
> > - 改变样式`para.setAttribute("class", "highlight")`
> >   发现一个好玩的，F12 点开浏览器后不是会有 Element 界面吗，然后我们执行事件，会发现我们用 js 写出来的，类似于 html 的结构的东西，会自动变成 html 语句，就是在 body 里面单加几行，可以直观的看到 js 写出来的结构，昨天学姐调出来那个界面让我找半天终于找到了.........(win!)
> >
> >   5.深入学习了计网关于物理层的知识，了解了各种信号传播途径，以及信号的各种理想的传播条件和传播原理，了解了各种专有名词，术语。调试了 AJAX 的相关环境和配置，目前不是很理解 AJAX 为什么这么复杂，深刻体会到前端不报错的痛苦。
> >
> > - **AJAX**就是史，报错就麻爪，
> >   `qql.html:1  Access to XMLHttpRequest at 'file:///C:/Users/daliang/Documents/study/AJAX/qql' from origin 'null' has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: chrome-extension, chrome-untrusted, data, edge, http, https, isolated-app.
qql.html:31   name file:///C:/Users/daliang/Documents/study/AJAX/qql net::ERR_FAILED`
> >   这段报错意思是浏览器禁止用 file:// 协议发 AJAX 请求，需要使用 vscode 里的`Open with Live Server`不是很理解，说是要装一个本地静态服务器，顺从了，我感觉只有在我学到 node.js 才能真正领会到。
> >
> > 6. 学习 axios，fetch，了解了如何在不更新浏览器网页的情况下通过热重载来使得浏览器能够发送请求到端口然后由端口返回 json（准确来说是字符串形式的 json）来进行数据传递，实现网页更新，学习了 axios，fetch 的框架来发送 ajax 请求，学习了同源策略
> >
> > - 同源策略是浏览器的一种安全策略
> >   > 协议，域名，端口号必须完全相同，违背同源策略就是跨源。
> > - 如何解决跨域
> >   > 1. jsonp（程序员发现的方法，仅仅支持 get 请求）
> >   >    > 通过 script 来引入 js 文件，使其在同一个协议，域名，端口号下，然后通过 send 或者 end 来返回在某个时间后返回的 js（行为），即返回的是一段完整的 js 代码，其中从 send 返回的其实是一段字符串（json），从而实现 json'数据的传输（有点怪怪的）
> >   > 2. CORS （官方解决方法，支持 get 和 post 请求）
> >   >    > 跨域资源共享，通过设置一个响应头，请求允许跨域，主要是服务端的设置
> > - 为什么非要跨域，设计同域，那么跨域有什么风险
> >   > 总结 kimi：防止系统错乱，但主要还是防人，防止有些不法之徒乱搞
> >   > **跨域本身不是漏洞，“把门开大了”才是**

###### qql
