我就不说我回答的情况了，把所有问题答案整理一下qwq  
全程无八股，无项目，全是各种语言特性和函数实现，好离谱

## 箭头函数和普通函数区别
可以了解下JS执行上下文，基本上都和执行上下文有关系

### this绑定
**function函数：**

this在函数被调用时动态绑定，它的指向取决于函数的调用方式：

+ 作为对象方法调用 ( `obj.method()` )：`this` 指向该对象 (`obj`)。
+ 作为普通函数调用 ( `func()` )：`this` 在严格模式下是 `undefined`，在非严格模式下指向全局对象（如 `window`）。
+ 使用 `new` 构造函数：`this` 指向新创建的实例。
+ 使用 `.call()`, `.apply()`, `.bind()`：`this` 被显式指定。

**箭头函数：**

this 在函数被定义时从其外层作用域继承而来的（词法绑定）

`**this**`** 的值一旦确定，就不会再改变，**`**call()**`**, **`**apply()**`**, **`**bind()**`** 无法改变箭头函数中 **`**this**`** 的指向。  **

```typescript
class Person {
    public name: string = "Alice";
    public age: number = 30;

    // 1. 使用 function
    sayNameFunction() {
        // 'this' 在这里指向 Person 实例
        console.log("My name is " + this.name); // 输出: My name is Alice

        setTimeout(function() {
            // 'this' 在 setTimeout 的回调（普通函数）中
            // 在严格模式下是 undefined，在非严格模式下是 window/global
            // 它不是 Person 实例！
            console.log("[function] What is my name? " + this.name);
        }, 500);
    }

    // 2. 使用箭头函数
    sayNameArrow() {
        setTimeout(() => {
            // 箭头函数从外层 'sayNameArrow' 方法“捕获”了 this
            // 这里的 'this' *仍然* 是 Person 实例！
            console.log("[Arrow] My name is " + this.name); // 输出: [Arrow] My name is Alice
        }, 1000);
    }
}

const person = new Person();
person.sayNameFunction();
person.sayNameArrow();
```

### arguments对象
**function函数：**

 函数内部有一个特殊的、类数组的 `arguments` 对象，它包含了调用时传递给函数的所有参数。

**箭头函数：**

+ **没有自己**的 `arguments` 对象。
+ 如果在箭头函数内部访问 `arguments`，它会引用**外层（最近的）普通函数**的 `arguments` 对象。
+ 在 TS (或 ES6+) 中，推荐使用**剩余参数 (Rest Parameters)** (`...args`) 来代替 `arguments`，它在两种函数中都可以使用，并且是真正的数组。

```typescript
// 1. 使用 function
function traditionalFunction(a: number) {
    console.log(arguments); // 输出: { '0': 1, '1': 2, '2': 3 }
    console.log(arguments[0]); // 输出: 1
}
traditionalFunction(1, 2, 3);


// 2. 使用箭头函数
const arrowFunction = (a: number) => {
    console.log(arguments); 
    // 编译时错误（在顶层作用域）或引用外层函数的 arguments
    // TS 错误: "The 'arguments' object is not available in arrow functions."
    // 或者 "Cannot find name 'arguments'."
};
arrowFunction(1, 2, 3); // 会报错


// 3. 推荐的替代方案：剩余参数 (Rest Parameters)
function traditionalWithRest(a: number, ...args: any[]) {
    console.log(a);     // 输出: 1
    console.log(args);  // 输出: [2, 3] (这是一个真数组)
}
traditionalWithRest(1, 2, 3);

const arrowWithRest = (a: number, ...args: any[]) => {
    console.log(a);     // 输出: 1
    console.log(args);  // 输出: [2, 3] (这是一个真数组)
};
arrowWithRest(1, 2, 3);
```

###  作为构造函数
**function函数：**

+ 可以作为构造函数使用，通过 `new` 关键字来创建新的对象实例。

**箭头函数:**

+ **不能**作为构造函数使用。
+ 如果尝试对箭头函数使用 `new`，程序会抛出一个 `TypeError` (例如：`... is not a constructor`)。
+ 没有 `prototype` 属性。

### 函数声明提升
这个好理解，function默认提升；箭头函数依赖于变量声明的关键字，但即使var变量被提升，它仍然是undefined。

## Map相比普通Object有何特点和优势？
### key的类型
```typescript
const obj = {};
obj[{}] = "value"; // 键会被转为字符串 "[object Object]"
console.log(obj); // { '[object Object]': 'value' }

const map = new Map();
map.set({}, "value");
console.log(map); // Map(1) { {} => 'value' }
```

### 键值对的顺序
Map的keys会**按照插入顺序排列**

### 内置方法
+ Map支持forEach（严格遍历自己的键值对，不会遍历原型链）
+  支持 `.size` 属性 

###  更高效的性能和内存管理
+ Object通过哈希表实现，并且可能存在原型链查找
+ Map通常通过稳定的哈希表或平衡树实现，优化了内存管理，更适用于需要频繁操作键值对的场景  

## 什么情况下使用Set？利用Set将一个数组去重(这个ez)
+ **去重**
+ **快速查找**：`Set` 内部采用哈希表实现，查找操作时间复杂度是 O(1)
+ **集合运算**：`Set` 提供了并集、交集、差集等集合运算方法

```typescript
function removeDuplicates(arr: any[]): any[] {
    return [...new Set(arr)];
}

// 示例
const arr = [1, 2, 2, 3, 4, 4, 5];
const uniqueArr = removeDuplicates(arr);
console.log(uniqueArr);  // 输出: [1, 2, 3, 4, 5]
```

## super函数用法
都是基于原型链的一些作用。

+ 在子类的构造函数中，可以使用 `super()` 调用父类的构造函数
+ 在子类重写了父类的方法后，`super` 仍然可以用来调用父类的方法

> **注意：因为必须确保子类实例拥有父类的所有属性，**`**super**`** 必须在子类的构造函数中调用 **`**this**`** 之前调用，这样子类实例才能正常访问和修改父类的属性**
>

## Promise相关方法，Promise.all什么情况下使用？
+ resolve, reject, all, allSettled, race, finally

`Promise.all()` 适用于以下场景：

+ 当你需要并行处理多个异步操作，并且希望在所有操作完成后才继续处理。
+ 当你希望某个操作的失败能立刻影响到整个操作的结果。

### 实现一个Promise.all
```typescript
// 1. 扩展 PromiseConstructor 接口，声明我们的 allCustom 方法
declare global {
  interface PromiseConstructor {
    allCustom<T>(promises: (Promise<T> | T)[]): Promise<T[]>;
  }
}

// 2. 在 Promise 的静态方法中实现 allCustom
Promise.allCustom = async function <T>(promises: (Promise<T> | T)[]): Promise<T[]> {
  const results: T[] = [];
  
  for (let i = 0; i < promises.length; i++) {
    const value = promises[i];
    
    try {
      // 如果是 Promise，就等待它完成；否则直接把值推入结果数组
      const result = value instanceof Promise ? await value : value;
      results.push(result);
    } catch (error) {
      // 如果任何一个 Promise 被拒绝，返回的 Promise 立即拒绝
      return Promise.reject(error);
    }
  }
  
  // 所有 Promise 完成后，返回一个新的 resolved Promise，包含结果数组
  return Promise.resolve(results);
};

// 测试代码
const p1 = Promise.resolve(3);
const p2 = new Promise<number>((resolve) => setTimeout(resolve, 100, 5));
const p3 = 10;

Promise.allCustom([p1, p2, p3])
  .then((values) => {
    console.log(values); // [3, 5, 10]
  })
  .catch((error) => {
    console.error(error);
  });

```

## type和interface区别？
###  扩展和继承  
+ `interface` 可以通过 `extends` 来继承其他 `interface` 或类。
+ `type` 也可以通过交叉类型（`&`）来合并多个类型。

###  声明合并  
+ `interface` 允许声明合并（declaration merging）
+ `type` 不支持声明合并。

###  复杂类型
+ `type` 更灵活，可以定义联合类型、交叉类型、映射类型等。
+ `interface` 主要用于对象类型的定义，不如 `type` 灵活。

## 实现一个函数，接收a, b参数，如果a, b不同时为string或同时为number，触发类型检查报错
```typescript
type CheckBothStringOrBothNumber<A, B> = 
  A extends string ? (B extends string ? true : never) :
  A extends number ? (B extends number ? true : never) :
  never;

function checkTypes<A extends string | number, B extends string | number>(
  a: A, b: B
): CheckBothStringOrBothNumber<A, B> {
  return true as any; // 保证类型检查通过
}

// 编译时会报错，类型不一致
checkTypes('hello', 100);  // Error: Type 'string' is not assignable to type 'number'

// 正确的调用
checkTypes('hello', 'world'); // 没有错误
checkTypes(42, 100);          // 没有错误

```

## React中闭包可能存在问题，比如：在一个组件的onChange中setValue, 并且fetch(参数携带该value)，请求时携带参数将一直为旧值，为什么？如何解决？
**描述的情景：**

```jsx
import React, { useState } from 'react';

function ExampleComponent() {
  const [value, setValue] = useState('');
  
  const handleChange = (e) => {
    setValue(e.target.value);
    // 假设此时需要用value进行fetch请求
    fetchData();  // 这里会使用到旧值
  };

  const fetchData = () => {
    console.log('Fetching with value:', value);  // 这里输出的值可能是旧值
    // 假设这是发起的请求
    fetch(`https://api.example.com/data?param=${value}`)
      .then((response) => response.json())
      .then((data) => {
        console.log(data);
      });
  };

  return <input type="text" value={value} onChange={handleChange} />;
}
```

### 问题解释：
在上面的例子中，`handleChange`函数会被触发并调用`setValue`来更新`value`的状态。但是，由于`setValue`是异步的，更新后的`value`并不会立即生效。因此，`fetchData`在调用时，仍然使用的是`setValue`调用时的旧值，导致请求参数一直是旧的。

### 如何解决？
+ 使用React的`useEffect`钩子来监听`value`的变化
+ 使用`setValue`的回调形式 （适用于类组件）  

```jsx
class ExampleComponent extends React.Component {
  state = {
    value: ''
  };

  handleChange = (e) => {
    this.setState({ value: e.target.value }, () => {
      // 这里可以在setState更新后立刻拿到最新的state
      this.fetchData(this.state.value);
    });
  };

  fetchData = (value) => {
    console.log('Fetching with value:', value);
    fetch(`https://api.example.com/data?param=${value}`)
      .then((response) => response.json())
      .then((data) => {
        console.log(data);
      });
  };

  render() {
    return <input type="text" value={this.state.value} onChange={this.handleChange} />;
  }
}
```

