### 第五次周报
***
#### 学习记录
TS + vue3

#### 一些不足
- 遇到问题几乎不看文档 只用ai
- 学的比较浅显 没有深入思考探究
- 学过的记不住记不住记不住

#### 下周计划
1. 复习JS和Vue3
2. 补一下vue2和axios
3. 写点东西

***
#### 学习笔记
##### TS
1. 基本类型和联合类型
```
let str1:string = 'abc'
let num:number = 1
let bool:boolean = true
let nu:null = null
let un:undefined = undefined
```
```
let v1:string | null = null
//let v2:1 | 2 | 3 = 5  报错
let v2:1 | 2 | 3 = 2 
```
2. 数组 元组 枚举
```
let arr:number[] = [1,2,3]
let arrstr:Array<string> = ['1','2']

let t1:[number,string,number?] = [1,'a']

enum MyEnum {
    A,
    B,
    C
}
```
3. 函数
```
function MyFn (a=20,b:string,c:boolean,...rest:number[]):number{
    return 100
}
//()里是参数 
//?是可选参数 
//...rest是剩余参数 
//()后面是返回值类型
const f = MyFn(20,'abc',true,1,2,3)
```
4. 接口
```
interface Obj {
    name:string,
    age:number
}
const obj:Obj = {
    name:'a',
    age:18
}
```
5. 泛型 一组相同类型的数据
```
function myFn<T>(a:T,b:T):T[]{
    return [a,b]
}
myFn<number>(1,2)
```
6. 函数重载
```
function hello (name:string):string
function hello (age:number):string

function hello (value:string | number):string{
    if(typeof value === 'string'){
        return '你好，我的名字是' + value
    }else if(typeof value === 'number'){
        return '你好，我的年龄是' + value
    }else {
        return '非法格式'
    }
}
hello('lisi')
hello(18)
```
7. 接口继承
```
interface Parent {
    prop1:string,
    prop2:number
}

interface Child extends Parent{
    prop3:number
}
const myobj:Child = {
    prop1:'123',
    prop2:1,
    prop3:3
}
```
8. 类的修饰符
```
class Article {
    //不写修饰符 默认public
    //必选属性
    public title:string
    content:string
    //可选属性
    aaa?:string
    //设置属性默认值
    bbb = 100

    //私有属性只能在类的内部访问
    private tempData?:string

    //被保护的 只能在当前类或者子类中访问
    protected innerData?:string

    //static 静态属性 设置给类本身 而不是设置给类的实例
    static author:string

    //联合使用 只读 不能修改
    private static readonly date:string = '2009-10-01'

    constructor (title:string,content:string){
        this.title = title
        this.content = content
    }
}
const article = new Article('标题','内容')

//article.author 报错
Article.author //正确

class B extends Article{
    constructor(title:string,content:string){
        super(title,content)
        this.innerData //可以访问
    }
}
```
9. 抽象类 基类 不需要实例化 用来规范格式
抽象类里有抽象属性、方法 也有非抽象属性、方法
```
abstract class Animal{
    abstract name:string
    abstract makeSound():void
    move():void{
        console.log('move')
    }
}
class Cat extends Animal{
    name:string = 'cat'
    makeSound():void{
    }
}
```
10. 通过类实现接口
```
interface Animal1{
    name:string
    sound:string
    makesound():void
}
interface C{
    age:number
}
class Dog implements Animal1,C{
    name:string = 'dog'
    age:number = 2
    sound:string = '汪汪汪'
    makesound():void{
    }
}
```
11. 泛型类
```
class MyClass<T>{
    public value:T
    constructor(value:T){
        this.value = value
    }
    do(input:T):T{
    console.log(this.value)
    return input
    }
}

const myStr1 = new MyClass<string>('haha')
myStr1.do('abcd')
const myNum = new MyClass<number>(123)
myNum.do(456)
```
##### Vue3
###### 核心语法
1. 创建应用：`createApp(App).mount('#app')`
2. 模板语法：
- 插值表达式`{{ msg }}`
- 指令：`v-bind:`、`v-on@`、`v-if`、`v-show`、`v-for`、`v-model`
- 事件绑定：`@click`、事件对象、事件修饰符 .stop .prevent .once
3. 计算属性
computed(()=>{}) 计算缓存 在{}里get set(val)可以修改为val
4. 监视: ref定义的基本类型数据、reactive定义的、函数返回一个值（getter函数）、包含以上上述的数组
- watch(source, callback)
- watchEffect(()=>{})
4. 条件渲染
`v-if / v-else-if / v-else`
`v-show`
5. 列表渲染
`v-for="item in list" :key="item.id"`
避免 key 使用 index
6. 表单双向绑定（v-model）
文本框、复选框、单选框、下拉框

###### 组合式API
1. setup() 基础 运行在组件创建前 无 this，组合逻辑更清晰
2. reactive / ref
- ref(基本类型 + 对象类型)  .value
- reactive(复杂类型)
- toRefs() / toRef()  接收一个reactive定义的响应式对象 分别解构成ref类型
- shallowRef / shallowReactive  都只能修改最外层
解构陷阱：reactive 解构会失去响应式
3. 生命周期
- vue3的生命周期:创建setup 挂载onBeforeMount onMounted 更新onBeforeUpdate onUpdated 卸载onBeforeUnmount onUnmounted
- vue2的生命周期:创建 挂载 更新 销毁
4. 组件通信（Vue3 重点）
- 父 → 子：props
- 子 → 父:自定义事件
- 任意组件通信：emit('事件名', 数据)
- v-model 组件：modelValue + update:modelValue
- 父 → 孙： $attrs
- $refs和$parent
- 跨层通信：provide / inject

###### 组件系统
1. props:单向数据流、类型校验、默认值、required
2. emit
defineEmits(['update:modelValue', 'delete'])
3. 插槽（slot）
默认插槽
具名插槽 #header
作用域插槽 → 把数据暴露给父组件
4. 动态组件
`<component :is="componentName" />`

###### 路由
1. 基本配置
createRouter
createWebHistory
2. 路由参数
params → /user/:id
query → /search?key=xxx
3. 嵌套路由
children: []
4. 编程式导航
router.push({ name: 'user', params: {} })

###### 状态管理（Pinia）
1. 定义 store
```
export const useUserStore = defineStore('user', {
  state: () => ({ name: 'aa' }),
  actions: { setName() {} },
  getters: { double() {} }
})
```
2. 使用 store
```
const user = useUserStore()
user.name
user.setName()
```

###### Composition API 高阶内容
1. 自定义 hooks
文件名：useXxx.ts
能复用逻辑
2. 依赖注入
provide('key', value)
inject('key')
3. Teleport
将组件挂载到其他 DOM 节点
4. Suspense
用于异步组件的加载状态（实验性）

###### 工程化（Vite + 构建）
1. Vite 工程结构
src 目录
assets 静态资源
components
views
2. 别名
@ → src 目录

###### TypeScript + Vue3
1. 组件类型声明
`<script lang="ts" setup>`
2. props 类型声明
`defineProps<{ name: string }>`
3. emits 类型声明
`defineEmits<{ (e:'click', id:number): void }>()`

###### 常见错误与坑
- reactive 解构失去响应式 → 使用 toRefs
- setup 里不能用 this
- 父子组件 props 名字不一致
- emit 和接收事件名大小写不一致
- v-for 缺 key 导致更新错误
- ref 访问 DOM 要 onMounted






