## 第六次周报
***
## 学习记录
小兔鲜项目开始

***
## 学习笔记
### 整体结构
#### 目录
```
src
├─ apis/          # 所有接口请求（axios 封装）
│  ├─ home.js
│  └─ layout.js
│
├─ assets/        # 静态资源（图片、字体等）
│
├─ components/    # 全局公共组件
│
├─ composables/   # 组合式函数（useXxx）
│
├─ directives/    # 统一管理「自定义指令」
│  └─ index.js
│
├─ router/        # 路由配置
│  └─ index.js
│
├─ stores/        # Pinia 状态管理
│  └─ category.js
│
├─ styles/        # 全局样式
│
├─ utils/         # 工具函数
│  └─ http.js
│
├─ views/         # 页面级组件（路由对应页面）
│  ├─ Home/
│  ├─ Category/
│  ├─ Layout/    #入口组件 分成大模块 Nav Header Footer
│  └─ Login/
│
├─ App.vue
└─ main.js
```

#### views————页面  商的各个页面
```
views/         # 页面级组件（路由对应页面）
├─ Home/
├─ Category/
├─ Layout/
└─ Login/
```
每个文件夹对应一个页面，文件夹里包含index.vue文件和components组件文件夹
```
index.vue     # 页面主体
components/   # 只给这个页面用的小组件
```

#### apis————用来集中管理所有接口请求，让页面不直接写 axios
里面的不同文件分别写不同页面的接口
```
apis/          # 所有接口请求（axios 封装）
├─ home.js     # 首页相关接口
└─ layout.js   #
```
##### 接口代码：
```
// apis/home.js
import httpInstance from '@/utils/http'  //引入封装好的 axios

export function getCategoryAPI () {   //getCategoryAPI为接口函数
  return httpInstance({     //返回请求结果
    url: '/home/category/head'    //url：后端接口地址
  })
}
```
##### 作用：
定义接口函数 描述接口含义  返回请求结果
##### 页面使用api:
```
import { getCategoryAPI } from '@/apis/home'  //从apis文件夹中，引入“获取分类数据”的接口函数

const categoryList = ref([])  //定义一个响应式数据，用来存“分类列表”

onMounted(async () => {
  const res = await getCategoryAPI()  //调用接口函数，获取后端数据
  categoryList.value = res.result   //把后端返回的数据，存进响应式变量
})
```
- 页面在onMounted生命周期中调用封装好的接口函数getCategoryAPI，通过axios请求后端获取分类数据，再将返回结果赋值给响应式变量categoryList，利用Vue的响应式系统实现数据驱动视图更新。

#### utils/http.js————用来统一封装axios，集中处理所有请求的公共逻辑。
httpInstance是配置好的axios实例
utils/http.js主要用来创建axios实例、请求拦截器、响应拦截器、对外“只暴露一个httpInstance”
**代码实现：**
```
//配置基础实例
//axios基础封装
import axios from 'axios'

const httpInstance = axios.create({
  //接口基地址
  baseURL:'http://pcapi-xiaotuxian-front-devtest.itheima.net',
  //接口超时时间
  timeout:5000
})

//拦截器
// axios请求拦截器
httpInstance.interceptors.request.use(config => {
  return config
}, e => Promise.reject(e))

// axios响应式拦截器
httpInstance.interceptors.response.use(res => res.data, e => {
  return Promise.reject(e)
})
//导出
export default httpInstance
```

#### apis/和utils/
##### utils/http.js
- axios 配置
- 请求 / 响应拦截器
- token
- 错误处理
- 路由跳转
**工具层（底层）**
##### apis
- 业务接口
- 接口语义化
- 返回数据
**业务接口层（上层）**

#### stores/————用来存放Pinia的“全局状态”，解决多个页面共享数据的问题。
stores 文件夹用于集中管理基于 Pinia 的全局状态，存放在多个组件和页面之间共享的数据，例如用户信息、登录状态和购物车数据，从而避免多层传参，提高项目的可维护性

#### router/————用来集中管理“页面跳转规则”（路由配置）。
index.js定义整个项目“所有页面怎么跳”
```javascript
//createRouter 创建router实例对象
//createWebHistory 创建history模式的路由

import { createRouter, createWebHistory } from 'vue-router'
//导入路由
import Login from '@/views/Login/index.vue'
import Layout from '@/views/Layout/index.vue'
import Home from '@/views/Home/index.vue'
import Category from '@/views/Category/index.vue'

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  //放payh和components对应关系的位置
  routes: [
    {
      path:'/',
      component:Layout,
      children:[
        {
          path:'',  //默认页
          component:Home
        },
        {
          path: 'category',
          component: Category
        }
      ]
    },
    {
      path: '/login',
      component: Login
    }
  ],
})

export default router
```

### Layout
layout分为Nav、Header、二级路由出口、Footer四部分
##### 快速搭建组件结构
1. 在components文件夹的LayoutNav、LayoutHeader、LayoutFooter文件里写入静态模板(template和style)
2. 在index.vue里引入 加载整体布局
```vue
<script setup>
//引入布局相关组件
import LayoutNav from './components/LayoutNav.vue'
import LayoutHeader from './components/LayoutHeader.vue'
import LayoutFooter from './components/LayoutFooter.vue'
import LayoutFixed from './components/LayoutFixed.vue'

//触发获取导航列表的action
import {useCategoryStore} from '@/stores/category'
import { onMounted } from 'vue'

const categoryStore = useCategoryStore()   //创建store实例
onMounted(()=> categoryStore.getCategory())
</script>

<template>
  <LayoutFixed />   //固定工具栏
  <LayoutNav />     //顶部导航
  <LayoutHeader />  //头部区域
  <RouterView />    //是“路由组件的占位符”，
  <LayoutFooter />  //底部
</template>
```
**`<RouterView />`**：是Vue Router提供的路由视图容器，用于根据当前路由路径，动态渲染匹配的组件内容，是实现页面切换和布局路由的核心。

##### 一级导航
一级分类列表 = 网站中商品的最顶层分类，用来在导航栏或分类页展示商品大类。
1. apis/layout.js
- 专门封装“布局相关的后端接口”，对外提供获取数据的方法。
```javascript
import httpInstance from "@/utils/http";  //引入已经配置好的axios实例,以后所有接口请求，都通过httpInstance发

//getCategoryAPI()接口函数,对外只暴露一个“行为”：获取一级分类列表数据
export function getCategoryAPI(){
  return httpInstance({
    url:'/home/category/head'
  })
}
```
2. LayoutHeader.vue 页面加载时，从后端获取一级分类列表，然后渲染导航
```vue
<script setup>
  // 导入接口函数getCategoryAPI
  import { getCategoryAPI } from '@/apis/layout'  
  import { onMounted, ref } from 'vue'

  // 定义变量categoryList，用于存放获取到的一级分类数组
  const categoryList = ref([])

  // 定义一个异步函数getCategory
  // 调用getCategoryAPI()向后端请求一级分类数据
  // 将返回数据res.result 赋值给 categoryList.value
  const getCategory = async () => {
    const res = await getCategoryAPI()
    categoryList.value = res.result
  }

  // 组件挂载完成后执行getCategory()
  onMounted(() => getCategory())
</script>

<template>
  // <RouterLink> = 路由跳转的“专用超链接”
  <header class='app-header'>
    <div class="container">
      <h1 class="logo">
        <RouterLink to="/">小兔鲜</RouterLink>
      </h1>
      <ul class="app-header-nav">
        <li class="home" v-for="item in categoryList" :key="item.id">
          <RouterLink to="/">{{ item.name }}</RouterLink>
        </li>
      </ul>
      <div class="search">
        <i class="iconfont icon-search"></i>
        <input type="text" placeholder="搜一搜">
        </div>
      <!-- 头部购物车 -->
    </div>
  </header>
</template>
```

##### 吸顶导航
1. 在LayoutFixed.vue写入静态模板
```vue

<style scoped lang='scss'>
.app-header-sticky {
  width: 100%;
  height: 80px;
  position: fixed;
  left: 0;
  top: 0;
  z-index: 999;
  background-color: #fff;
  border-bottom: 1px solid #e4e4e4;
  // 此处为关键样式!!!
  // 初始（隐藏）状态
  transform: translateY(-100%);  //整个头部往上移动自身高度（完全离开可视区域）
  opacity: 0;  //完全透明

  // 显示状态
  &.show {
    transition: all 0.3s linear;  //平滑动画
    transform: none;  //移动回原位置
    opacity: 1;   //完全可见
  }
```

2. 实现吸顶交互
> 核心逻辑：根据滚动距离判断当前show类名是否显示，大于78显示，小于78，不显示
在LayoutFixed.vue文件里
```vue
<script setup>
// vueUse
import { useScroll } from '@vueuse/core'
const { y } = useScroll(window)
</script>

<template>
  <div class="app-header-sticky" :class="{ show: y > 78 }">
    <!-- 省略部分代码 -->
  </div>
</template>
```

##### pinia优化重复请求
1. stores/category.js文件 用于管理“小兔鲜项目一级导航的状态和数据”
```javascript
import { ref } from 'vue'
import { defineStore } from 'pinia' //Pinia提供的定义store的方法
import { getCategoryAPI } from '@/apis/layout'   //从apis获取一级分类接口，用于异步请求数据

//useCategoryStore是获取Pinia中名为category的store实例的函数，通过它可以在组件里访问和操作store的状态（state）和方法（action）。
export const useCategoryStore = defineStore('category', () => {
  // 导航列表的数据管理
  // state 存储导航列表数据 到变量categoryList 
  const categoryList = ref([])

  // action 获取导航数据的方法
  //调用getCategoryAPI()请求后端数据
  //将返回数据存入 categoryList
  //组件使用时调用 getCategory() 即可

  const getCategory = async () => {
    const res = await getCategoryAPI()
    categoryList.value = res.result
  }

  //返回给组件使用
  return {
    categoryList,
    getCategory
  }
})
```
组件可以这么使用：
```vue
import { useCategoryStore } from '@/stores/category'
const categoryStore = useCategoryStore()

```
###### 举例 一级导航渲染中
1. 不使用pinia：LayoutHeader.vue文件：
```vue
<script setup>
  import { getCategoryAPI } from '@/apis/layout'  
  import { onMounted, ref } from 'vue'

  const categoryList = ref([])

  const getCategory = async () => {
    const res = await getCategoryAPI()
    categoryList.value = res.result
  }

  onMounted(() => getCategory())
</script>
```
2. 使用pinia：stores/category.js文件 + 以下（LayoutHeader.vue）
```vue
<script setup>
import { useCategoryStore } from '@/stores/category';

//使用pinia中的数据
const categoryStore = useCategoryStore()
</script>
```

### Home
#### 整体结构创建
home页为：左侧分类和轮播图 + 新鲜好物 + 人气推荐 + 产品列表
1. 创建HomeCategory、HomeBanner、HomeNew、HomeHot、HomeProduct五个文件
2. 在Home模块入口组件引入并渲染
```vue
<script setup>
import HomeCategory from './components/HomeCategory.vue'
import HomeBanner from './components/HomeBanner.vue'
import HomeNew from './components/HomeNew.vue'
import HomeHot from './components/HomeHot.vue'
import HomeProduct from './components/HomeProduct.vue'
</script>

<template>
  <div class="container">
    <HomeCategory />
    <HomeBanner />
  </div>
  <HomeNew />
  <HomeHot />
  <homeProduct />
</template>
```

#### 左侧分类实现 HomeCategory
1. 详细静态模板
2. 代码实现
```vue
<script setup>
//引入获取分类store的函数
import { useCategoryStore } from '@/stores/category'
//实例化 categoryStore
const categoryStore = useCategoryStore()
</script>

<template>
  <div class="home-category">
    <ul class="menu">
      <li v-for="item in categoryStore.categoryList" :key="item.id">
        <RouterLink to="/">{{ item.name }}</RouterLink>
        // 只放前两个
        <RouterLink v-for="i in item.children.slice(0, 2)" :key="i" to="/">{{ i.name }}</RouterLink>
        <!-- 弹层layer位置 -->
        <div class="layer">
          <h4>分类推荐 <small>根据您的购买或浏览记录推荐</small></h4>
          <ul>
            <li v-for="i in item.goods" :key="i.id">
              <RouterLink to="/">
                <img :src="i.picture" alt="" />
                <div class="info">
                  <p class="name ellipsis-2">
                    {{ i.name }}
                  </p>
                  <p class="desc ellipsis">{{ i.desc }}</p>
                  <p class="price"><i>¥</i>{{ i.price }}</p>
                </div>
              </RouterLink>
            </li>
          </ul>
        </div>
      </li>
    </ul>
  </div>
</template>
```

#### banner轮播图实现 HomeBanner
##### 1. 写入静态模板
##### 2. 获取数据渲染组件
1- 封装接口 创建apis/home.js 存放home相关接口
```javascript
/**
 * @description: 获取banner图
 * @param {*}
 * @return {*}
 */
//引入封装好的axios实例httpInstance
import  httpInstance  from '@/utils/http'
//用于从后端获取轮播图（Banner）数据的接口函数
export function getBannerAPI (){
  return httpInstance({
    url:'home/banner'
  })
}
```
2- 获取数据渲染模版
```vue
<script setup>
//引入接口函数
import { getBannerAPI } from '@/apis/home'
import { onMounted, ref } from 'vue'

//定义响应式数据 bannerList：保存 banner 列表
const bannerList = ref([])

// 定义一个异步函数getBanner
// 调用getBannerAPI()向后端请求轮播图数据
// 将返回数据res.result 赋值给 bannerList.value
const getBanner = async () => {
  const res = await getBannerAPI()
  bannerList.value = res.result
}

onMounted(() => getBanner())
</script>

<template>
  <div class="home-banner">
    <el-carousel height="500px">
      <el-carousel-item v-for="item in bannerList" :key="item.id">
        <img :src="item.imgUrl" alt="">
      </el-carousel-item>
    </el-carousel>
  </div>
</template>
```

#### 面板组件封装
- 作用：复用结构、统一样式、降低重复代码、提升项目可维护性。
- 核心思路：把可复用的结构只写一次，把可能发生变化的部分抽象成组件参数（props/插槽）

##### 实现步骤：
- 不做任何抽象，准备静态模板
- 对于抽象可变部分：
1. 纯文本抽象为prop传入
2. 复杂模板抽象成插槽传入

###### HomePanel.vue文件
```vue
<script setup>
//定义props
defineProps({
  title:{
    type:String
  },
  subTitle:{
    type:String
  }
})
</script>


<template>
  <div class="home-panel">
    <div class="container">
      <div class="head">
         <!-- 主标题和副标题 -->
        <h3>
          {{ title }}<small>{{ subTitle }}</small>
        </h3>
      </div>
      <!-- 主体内容区域 -->
      <slot />
    </div>
  </div>
</template>
```

#### 新鲜好物实现
##### 1. 封装接口 apis/home.js
```javascript
/**
 * @description: 获取新鲜好物
 * @param {*}
 * @return {*}
 */
//向后端请求“新鲜好物”列表数据
//这种写法可以避免函数提升带来的歧义
export const findNewAPI = () => {
  return httpInstance({
    url:'/home/new'
  })
}
```
##### 2. 获取数据渲染模版 
```vue
<script setup>
//引入面板组件
import HomePanel from './HomePanel.vue'
import { findNewAPI } from '@/apis/home'
import { ref } from 'vue'

//获取数据
const newList = ref([])
const getNewList = async () => {
  const res = await getNewAPI()
  newList.value = res.result
}

getNewList()
</script>

<template>
  //模板渲染 写入title和sub-title
  <HomePanel title="新鲜好物" sub-title="新鲜出炉 品质靠谱">
    <ul class="goods-list">
      <li v-for="item in newList" :key="item.id">
        <RouterLink :to="`/detail/${item.id}`">
        <img :src="item.picture" alt="" />
        <p class="name">{{ item.name }}</p>
        <p class="price">&yen;{{ item.price }}</p>
        </RouterLink>
      </li>
    </ul>
  </HomePanel>
</template>
```

#### 人气推荐实现
##### 1. 封装接口
```javascript
/**
 * @description: 获取人气推荐
 * @param {*}
 * @return {*}
 */
export const getHotAPI = () => {
  return  httpInstance('home/hot', 'get', {})
}
```
##### 2. 获取数据渲染模版
```vue
<script setup>
import HomePanel from './HomePanel.vue'
import { getHotAPI } from '@/apis/home'
import { ref } from 'vue'
const hotList = ref([])
const getHotList = async () => {
  const res = await getHotAPI()
  hotList.value = res.result
}
getHotList()

</script>

<template>
  <HomePanel title="人气推荐" sub-title="人气爆款 不容错过">
      <ul class="goods-list">
        <li v-for="item in hotList" :key="item.id">
          <RouterLink to="/">
            <img v-img-lazy="item.picture" alt="">
            <p class="name">{{ item.title }}</p>
            <p class="desc">{{ item.alt }}</p>
          </RouterLink>
        </li>
      </ul>
  </HomePanel>
</template>
```

#### 懒加载指令实现
场景：页面很长，页面靠下的图片，通过懒加载优化手段可以达到只有进入视口区域才发送图片请求
指定用法：`<img v-img-lazy="item.picture" />`
##### 1. 封装全局指令 directives/index.js
```javascript
// 定义懒加载插件
import { useIntersectionObserver } from '@vueuse/core'

export const lazyPlugin = {
  install (app) {
    // 懒加载指令逻辑
    app.directive('img-lazy', {
      mounted (el, binding) {
        // el: 指令绑定的那个元素 img
        // binding: binding.value  指令等于号后面绑定的表达式的值  图片url
        console.log(el, binding.value)
        // 解决重复监听问题
        const { stop } = useIntersectionObserver(
          el,
          ([{ isIntersecting }]) => {
            console.log(isIntersecting)
            if (isIntersecting) {
              // 进入视口区域
              el.src = binding.value
              stop()
            }
          },
        )
      }
    })
  }
}
```
##### 2. 注册全局指令 main.js
```javascript
//引入懒加载插件并注册
import { lazyPlugin } from '@/directives'
app.use(lazyPlugin)
```
**解决逻辑书写位置不合理问题**
##### 3.把`<img v-img-lazy="item.picture" />`添加到相关位置

#### Product产品列表实现
##### 1. 基础数据渲染
1- 准备静态模版
2- 封装接口
```javascript
/**
 * @description: 获取所有商品模块
 * @param {*}
 * @return {*}
 */
export const getGoodsAPI = () => {
  return httpInstance({
    url: '/home/goods'
  })
}
```
3- 获取并渲染数据
```vue
<script setup>
import HomePanel from './HomePanel.vue'
import { getGoodsAPI } from '@/apis/home'
import { ref } from 'vue'

const goodsProduct = ref([])
const getGoods = async () => {
  const { result } = await getGoodsAPI()
  goodsProduct.value = result
}
onMounted( ()=> getGoods() )
</script>

<template>
  <div class="home-product">
    <HomePanel :title="cate.name" v-for="cate in goodsProduct" :key="cate.id">
      <div class="box">
        <RouterLink class="cover" to="/">
          <img :src="cate.picture" />
          <strong class="label">
            <span>{{ cate.name }}馆</span>
            <span>{{ cate.saleInfo }}</span>
          </strong>
        </RouterLink>
        <ul class="goods-list">
          <li v-for="goods in cate.goods" :key="good.id">
            <RouterLink to="/" class="goods-item">
              <img :src="goods.picture" alt="" />
              <p class="name ellipsis">{{ goods.name }}</p>
              <p class="desc ellipsis">{{ goods.desc }}</p>
              <p class="price">&yen;{{ goods.price }}</p>
            </RouterLink>
          </li>
        </ul>
      </div>
    </HomePanel>
  </div>
</template>
```
##### 2. 图片懒加载
```html
<div class="home-product">
  <HomePanel :title="cate.name" v-for="cate in goodsProduct" :key="cate.id">
    <div class="box">
      <RouterLink class="cover" to="/">
        <!-- 指令替换 -->
        <img v-img-lazy="cate.picture" />
      </RouterLink>
      <ul class="goods-list">
        <li v-for="goods in cate.goods" :key="goods.id">
          <RouterLink to="/" class="goods-item">
             <!-- 指令替换 -->
            <img v-img-lazy="goods.picture" alt="" />
          </RouterLink>
        </li>
      </ul>
    </div>
  </HomePanel>
</div>
```

#### GoodsItem组件封装
复用同样的商品展示模块
核心思想：把要显示的数据对象设计为props参数，传入什么数据对象就显示什么数据
##### 1. 封装组件 GoodsItem.vue
```vue
<script setup>
defineProps({
  goods: {
    type: Object,
    default: () => { }
  }
})
</script>

<template>
  <RouterLink to="/" class="goods-item">
    <img :src="goods.picture" alt="" />
    <p class="name ellipsis">{{ goods.name }}</p>
    <p class="desc ellipsis">{{ goods.desc }}</p>
    <p class="price">&yen;{{ goods.price }}</p>
  </RouterLink>
</template>
```
##### 2. 使用组件
```vue
<ul class="goods-list">
  <li v-for="goods in cate.goods" :key="goods.id">
    <GoodsItem :goods="goods" />
  </li>
</ul>
```
